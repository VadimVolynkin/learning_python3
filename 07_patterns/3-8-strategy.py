# ================================================================================================================
# STRATEGY
# ================================================================================================================
поведенческий паттерн
выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.

Класс делегирует выполнение вложенному объекту абстрактного типа или интерфейса.

Стратегия часто используется в Python-коде, особенно там, где нужно подменять алгоритм во время выполнения программы. Многие примеры стратегии можно заменить простыми lambda-выражениями.

# ================================================================================================================
# Концептуальный пример
# ================================================================================================================
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import List


# Контекст определяет интерфейс, представляющий интерес для клиентов
# Обычно Контекст принимает стратегию через конструктор, а также предоставляет сеттер для её изменения во время выполнения.
class Context():

    def __init__(self, strategy: Strategy) -> None:
        self._strategy = strategy


    # Контекст хранит ссылку на один из объектов Стратегии
    # Контекст не знает конкретного класса стратегии. Он должен работать со всеми стратегиями через интерфейс Стратегии
    @property
    def strategy(self) -> Strategy:
        return self._strategy

    # Обычно Контекст позволяет заменить объект Стратегии
    @strategy.setter
    def strategy(self, strategy: Strategy) -> None:
        self._strategy = strategy


    # Контекст делегирует реализацию множественных версий алгоритма объекту Стратегии
    def do_some_business_logic(self) -> None:
        result = self._strategy.do_algorithm(["a", "b", "c", "d", "e"])
        print(",".join(result))




# Интерфейс Стратегии объявляет операции, общие для всех поддерживаемых версий некоторого алгоритма
# Контекст использует этот интерфейс для вызова алгоритма, определённого Конкретными Стратегиями
class Strategy(ABC):

    @abstractmethod
    def do_algorithm(self, data: List):
        pass



# Конкретные Стратегии реализуют алгоритм, следуя базовому интерфейсу Стратегии
# Этот интерфейс делает их взаимозаменяемыми в Контексте
class ConcreteStrategyA(Strategy):
    def do_algorithm(self, data: List) -> List:
        return sorted(data)


class ConcreteStrategyB(Strategy):
    def do_algorithm(self, data: List) -> List:
        return reversed(sorted(data))


if __name__ == "__main__":

    # Клиентский код выбирает конкретную стратегию и передаёт её в контекст
    # Клиент должен знать о различиях между стратегиями, чтобы сделать правильный выбор
    context = Context(ConcreteStrategyA())                   # создание объекта контекста(принимает стратегиюА)
    context.do_some_business_logic()                         # a,b,c,d,e
    print()

    context.strategy = ConcreteStrategyB()                   # замена конкретной стратегии в объекте контекста
    context.do_some_business_logic()                         # e,d,c,b,a





































