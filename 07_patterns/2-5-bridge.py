
# ================================================================================================================
# BRIDGE
# ================================================================================================================
# Структурный паттерн проектирования 
# Один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
# Абстракция получит ссылку на объекты реализации и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.

Мост особенно полезен когда вам приходится делать кросс-платформенные приложения, поддерживать несколько типов баз данных или работать с разными поставщиками похожего API (например, cloud-сервисы, социальные сети и т. д.)

 Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).


Когда класс нужно расширять в двух независимых плоскостях.

Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.


# ================================================================================================================
# Концептуальный пример
# ================================================================================================================
from abc import ABC, abstractmethod


# Абстракция устанавливает интерфейс для «управляющей» части двух иерархий классов: абстракции и реализации
# Она содержит ссылку на объект из иерархии Реализации и делегирует ему всю настоящую работу
class Abstraction:

    def __init__(self, implementation: Implementation) -> None:
        self.implementation = implementation

    def operation(self) -> str:
        return (f"Abstraction: Base operation with:\n"
                f"{self.implementation.operation_implementation()}")


# Можно расширить Абстракцию без изменения классов Реализации
class ExtendedAbstraction(Abstraction):

    def operation(self) -> str:
        return (f"ExtendedAbstraction: Extended operation with:\n"
                f"{self.implementation.operation_implementation()}")


# Реализация устанавливает интерфейс для всех классов реализации
# Как правило, интерфейс Реализации предоставляет только примитивные операции, в то время как Абстракция определяет операции более высокого уровня, основанные на этих примитивах.
class Implementation(ABC):

    @abstractmethod
    def operation_implementation(self) -> str:
        pass



# Каждая Конкретная Реализация соответствует определённой платформе и использует API этой платформы
class ConcreteImplementationA(Implementation):
    def operation_implementation(self) -> str:
        return "ConcreteImplementationA: Here's the result on the platform A."


class ConcreteImplementationB(Implementation):
    def operation_implementation(self) -> str:
        return "ConcreteImplementationB: Here's the result on the platform B."


# клиентский код принимает объект абстракции
# клиентский код должен зависеть только от класса Абстракции, за исключением этапа инициализации, когда объект Абстракции связывается с определённым объектом Реализации
# клиентский код может поддерживать любую комбинацию абстракции и реализации
def client_code(abstraction: Abstraction) -> None:
    print(abstraction.operation(), end="")



# Клиентский код должен работать с любой предварительно сконфигурированной комбинацией абстракции и реализации
if __name__ == "__main__":
    implementation = ConcreteImplementationA()        # создание объекта конкретной реализацииА
    abstraction = Abstraction(implementation)         # создание объекта абстракции
    client_code(abstraction)

    print("\n")

    implementation = ConcreteImplementationB()        # создание объекта конкретной реализацииВ
    abstraction = ExtendedAbstraction(implementation) # создание объекта расширенной абстракции
    client_code(abstraction)








