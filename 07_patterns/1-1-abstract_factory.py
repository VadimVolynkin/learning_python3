https://www.youtube.com/watch?v=1mVONOCxfLg

порождающий паттерн
позволяет создавать группы взаимозависимых или связанных объектов, не конкретизируя классы этих объектов
задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций.

Клиентский код вызывает методы фабрики для получения продуктов, вместо самостоятельного создания с помощью оператора new. При этом фабрика сама следит за тем, чтобы создать продукт нужной вариации.


Паттерн можно часто встретить в Python-коде, особенно там, где требуется создание семейств продуктов (например, внутри фреймворков)

Паттерн можно определить по методам, возвращающим фабрику, которая, в свою очередь, используется для создания конкретных продуктов, возвращая их через абстрактные типы или интерфейсы.


# ================================================================================================================
# АБСТРАКТНАЯ ФАБРИКА
# ================================================================================================================
# Порождающий паттерн
# Абстрактная фабрика - это логическое расширение фабричного метода для достижения определённых задач обычно связаных с работой на нескольких платформах. Главное отличие - несколько методов реализующих интерфейс Фабрики(в паттерне Фабричный метод есть только 1 метод - он создает только 1 тип объекта)


# ================================================================================================================
# ПРИМЕР СОЗДАНИЯ ИНТЕРФЕЙСА ДЛЯ НЕСКОЛЬКИХ OS
# ================================================================================================================
# приложение работает с: win, linux
# приложение создает графический интерфейс: меню и окно для каждой из систем свой вариант
# клиентский код приложения знает для какой опер системы нужно создать интерфейс - создает объект конкретной фабрики
# далее запускаются методы создания интерфейса - они вернут объекты


from abc import ABC,abstractmethod

# Абстрактная фабрика определяет интерфейс для конкретных фабрик
# Может создать любой объект для любой операционной системы
# 1 метод для каждого интерфейса 
class AbstractFactory(ABC):

    @abstractmethod
    def create_menu():
        pass

    @abstractmethod
    def create_window():
        pass


# Конкретные фабрики реализуют интерфейс
# каждая фабрика будет иметь столько методов - сколько существует интерфейсов(в примере 2)
# каждый интерфейс каждой фабрики вернет свой конкретный объект(здесь это просто строка с названием)
class WinFactory():
    def create_menu(self):
        return 'WinMenu'

    def create_window(self):
        return 'WinWindow'


class LinuxFactory():
    def create_menu(self):
        return 'LinuxMenu'

    def create_window(self):
        return 'LinuxWindow'


# Запуск клиентского кода
# допустим приложение определило, что нужно создать интерфейс для Linux
os = LinuxFactory()               # создаем объект фабрики                      
menu = os.create_menu()           # создаем объекты интерфейса
window = os.create_window()
print(menu)                       # LinuxMenu
print(window)                     # LinuxWindow










