
# ================================================================================================================
# COMPOSITE(TREE, КОМПОНОВЩИК)
# ================================================================================================================
# Структурный паттерн проектирования
# Группирует множество объектов в древовидную структуру, чтобы работать с ней как с одним объектом
# Все операции компоновщика основаны на рекурсии и «суммировании» результатов на ветвях дерева.
# Встречается в любых задачах, которые связаны с построением дерева. 

# ===== Как создать
1. Создать класс Компонент с интерфейсом для листьев и веток
2. Создать класс Листья(Компонент) с полезной бизнес логикой
3. Создать класс Ветви(Компонент) с методами добавления, удаления и рекурсивной обработки


# ================================================================================================================
# Концептуальный пример
# ================================================================================================================
from abc import ABC, abstractmethod
from typing import List


# Базовый Компонент объявляет общий интерфейс для простых и сложных объектов структуры(контейнеров и листьев)
# Базовый Компонент может объявить интерфейс для установки и получения родителя компонента в древовидной структуре
class Component(ABC):
    
    @property
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, parent):
        self._parent = parent


    # Можно предоставить некоторую реализацию по умолчанию для методов - тогда не нужно предоставлять конкретные классы компонентов клиентскому коду даже во время сборки дерева объектов. Недостаток такого подхода в том, что эти методы будут пустыми для компонентов уровня листа.
    def add(self, component) -> None:
        pass

    def remove(self, component) -> None:
        pass

    # можно создать метод для проверки может ли компонент иметь вложенные объекты.
    def is_composite(self) -> bool:
        return False

    # Базовый Компонент может сам реализовать некоторое поведение по умолчанию или поручить это конкретным классам
    @abstractmethod
    def operation(self) -> str:
        pass


# Класс Лист - конечные объекты структуры. Лист не может иметь вложенных компонентов.
# Объекты Листьев выполняют фактическую работу, объекты Контейнера делегируют работу своим подкомпонентам.
class Leaf(Component):

    def operation(self) -> str:
        return "Leaf"


# Класс Контейнер содержит простые и сложные компоненты, которые могут иметь вложенные компоненты.
# Объекты Контейнеры делегируют фактическую работу своим детям, а затем «суммируют» результат.
class Composite(Component):

    def __init__(self) -> None:
        self._children: List[Component] = []

    # Объект контейнера может добавлять и удалять  простые и сложные компоненты в свой список вложенных
    def add(self, component: Component) -> None:
        self._children.append(component)
        component.parent = self

    def remove(self, component: Component) -> None:
        self._children.remove(component)
        component.parent = None

    def is_composite(self) -> bool:
        return True

    # Контейнер проходит рекурсивно через всех своих детей, собирая и суммируя их результаты.
    def operation(self) -> str:
        results = []
        for child in self._children:
            results.append(child.operation())
        return f"Branch({'+'.join(results)})"


# Клиентский код работает со всеми компонентами через базовый интерфейс
def client_code(component: Component) -> None:
    print(f"RESULT: {component.operation()}", end="")


# Если операции управления потомками объявлены в базовом классе Компонента, то клиентский код может работать как с простыми, так и со сложными компонентами, вне зависимости от их конкретных классов.
def client_code2(component1: Component, component2: Component) -> None:
    if component1.is_composite():
        component1.add(component2)

    print(f"RESULT: {component1.operation()}", end="")



if __name__ == "__main__":
    # # Клиентский код может поддерживать простые компоненты-листья
    simple = Leaf()                                      # создаем лист(простой объект)
    # client_code(simple)                                  # RESULT: Leaf


    # Сложные (контейнеры) с простыми
    tree = Composite()                                   # создаем дерево(сложный объект)

    branch1 = Composite()                                # создаем ветку1(сложный объект)
    branch1.add(Leaf())                                  # создаем лист и добавляем его к ветке1
    branch1.add(Leaf())                                  # создаем лист и добавляем его к ветке1

    branch2 = Composite()                                # создаем ветку2(сложный объект)
    branch2.add(Leaf())                                  # создаем лист и добавляем его к ветке2

    tree.add(branch1)                                    # добавляем ветку1 к дереву
    tree.add(branch2)                                    # добавляем ветку2 к дереву

    client_code(tree)                                    # RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf))
    client_code2(tree, simple)                           # RESULT: Branch(Branch(Leaf+Leaf)+Branch(Leaf)+Leaf)


























