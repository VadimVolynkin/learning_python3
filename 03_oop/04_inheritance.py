# ================================================================================================================
# НАСЛЕДОВАНИЕ
# ================================================================================================================
Наследование позволяет создавать новые классы на основе уже имеющихся классов. На этом принципе работает построение абстрактных классов(интерфейсов) и их реализаций(конкретных классов).
Потомки могут переопределить унаследованные методы(override) или создать свои.

Переопределение метода - его изменение внутри класса-наследника. Переопределять можно только публичные методы. С приватными методами это не работает - они независимы в каждом классе.

Перегрузка методов - выполнение разного функционала в зависимсти от переданных данных.


# ===== ГДЕ ПРИМЕНЯТЬ
Наследование полезнее всего для группировки сходных сущностей и понятий, определения семейств классов, и вообще для организации терминов и понятий, описывающих предметную область.

Наследуем, если:

    Оба класса из одной предметной области
    Наследник является корректным подтипом (в терминах LSP — прим. пер.) предка
    Код предка необходим, либо хорошо подходит для наследника
    Наследник в основном добавляет логику


Иногда все эти условия выполняются одновременно:

    в случае моделирования высокоуровневой логики из предметной области
    при разработке библиотек и расширений для них
    при дифференциальном программировании (автор снова использует термин "differential programming", очевидно, понимая под ним нечто, отличное от DDP — прим. пер.)


Используйте наследование вместо композиции:

- для моделирования четких отношений.
- чтобы использовать как интерфейс, так и реализацию базового класса.
- для предоставления функций смешивания (mixin) нескольким несвязанным классам, когда может существовать только одна реализация этой функции.

# ===== ПРОБЛЕМЫ НАСЛЕДОВАНИЯ
Проблема взрыва класса (class explosion problem).
Ромбовидное наследование (The Diamond Problem)  # при множественном наследовани(рассмотрено ниже)


# ================================================================================================================
# КАК СОЗДАТЬ СВОЙ КЛАСС
# ================================================================================================================
Классы создаются, наследуясь от других классов. Класс object - самый базовый класс в Питоне. При создании своего класса он наследуется неявно. Посмотреть всех предков любого класса можно так:

print(object.__mro__)     # (<class 'object'>,) родительским классом класса object тоже является класс object

# все наследники класса object получат это:
print(dir(object))        
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

# создаем свой класс
class MyClass:            # здесь неявное наследование от object: class MyClass(object)                
    pass

# в MyClass автоматически добавляется __dict__, __module__и __weakref__
print(dir(MyClass))
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']


# ================================================================================================================
# МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ и Порядок разрешения методов (Method Resolution Order / MRO)
# ================================================================================================================
При использовании множественного наследования может быть не всегда понятно от какого предка был получен метод или атрибут.
Питон предлагает средства для решения этой проблемы.

# === super().some_method() 
super() определяет базовый класс - обходит все родительские классы в определенном порядке только 1 раз (избавляет от возможной рекурсии).
С помощью super() можно вызвать любой метод или атрибут в базовом классе. Например, super().__init__(*args) вызовет конструктор базового класса. Передавать self в этом случае не нужно.

# === ChildClass.__mro__  или ChildClass.mro()  
MRO показывает порядок, в котором Python будет искать соответствующий атрибут или метод. (показывает порядок наследования в классе - Линеаризация)
При обращении к методу или атрибуту класса Python использует MRO
super() использует MRO для определения, какой метод или атрибут вызывать. 

# === isinstance(obj, int)
является ли объект экземпляром класса

# === issubclass(float, int)
является ли класс подклассом

# ===== КАК ПИТОН ИЩЕТ АТРИБУТ В КЛАССЕ
# 1. ищет в текущем классе
# 2. в классе родителей(если их несколько - слева направо в родителя1 и в его глубину, затем  в родителе2 ... по __mro__)
# 3. если нигде нет - AttributeError: object has no attribute

class BaseEnglish:
    def say_hello(self):
        print('hello')

class BaseSpanish:
    def say_hello(self):
        print('hola')

# создаем класс, наследуясь от двух классов
# вопрос: что выведет say_hello()
class Speak(BaseEnglish, BaseSpanish):
    pass


print(Speak.mro()) 
# [<class '__main__.Speak'>, <class '__main__.BaseEnglish'>, <class '__main__.BaseSpanish'>, <class 'object'>]
# Порядок поиска: Speak -> BaseEnglish -> BaseSpanish -> object

obj = Speak()
obj.say_hello()      # hello









