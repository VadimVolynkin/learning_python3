# ================================================================================================================
# АБСТРАКТНЫЕ КЛАССЫ и ИНТЕРФЕЙСЫ
# ================================================================================================================
Абстрактный класс - это класс у которого не может быть своих экземпляров, но они могут быть у наследников.
Абстрактный класс определяет методы и свойства, которые должны быть реализованы в классах наследниках.
У Абстрактного класса должен быть минимум 1 абстрактный метод.
У Абстрактного класса могут быть обычные методы с реализацией по умолчанию.
Абстрактные классы можно использовать для группировки классов по типу.

Классы Интерфейсы в отличии от абстрактных состоят только из абстрактных методов. В интерфейсе нет вообще никаких реализаций и данных. Это избавляет от возможных конфликтов при множественном наследовании.


# ================================================================================================================
# КАК СОЗДАТЬ АБСТРАКТНЫЙ КЛАСС
# ================================================================================================================

# === 1. Использование библиотеки abc(наиболее популярный вариант) ===============================================
from abc import ABC, abstractmethod, abstractproperty


# Наследование от ABC делает класс абстрактным - он не сможет создать объект
class Pizza(ABC):

    # @abstractmethod объявляет метод абстрактным - требует его реализации в наследниках
    # Метод может иметь реализацию здесь, тогда его можно вызвать в наследниках через super(), но он все равно будет требовать собственной реализации в классах-наследниках.
    # Метод может здесь ничего не определять - pass
    @abstractmethod
    def cook(self):
        pass
        # print('Готовим какую то пиццу')              # будет доступно через super()

    # @abstractproperty объявляет свойство абстрактным - требует его реализации в наследниках
    # @abstractproperty можно заменить на сочетание:
    # @property
    # @abstractmethod
    @abstractproperty
    def get_price(self):
        pass

    # обычный метод класса с реализацией по умолчанию
    def eat(self):
        print('Едим пиццу')


# Конкретный класс реализует абстрактные методы
class PizzaChease(Pizza):

    # реализация абстрактного метода
    def cook(self):
        print('pizza with chease was cooked')

    # реализация абстрактного свойства
    @property
    def get_price(self):
        print('Вычисляем цену')


class PizzaBacon(Pizza):

    # реализация абстрактного метода
    def cook(self):
        print('pizza with bacon was cooked')

    # реализация абстрактного свойства
        @property
        def get_price(self):
            print('Вычисляем цену')


# клиентский код определяет что делать с объектами
def client_code(pizza):
    pizza.cook()
    pizza.eat()
    pizza.get_price()


if __name__ == '__main__':

    # создаем объекты пиццы
    pizza_chease = PizzaChease()
    pizza_bacon = PizzaBacon()

    # вызов клиентского кода
    client_code(pizza_chease)
    client_code(pizza_bacon)


# === 2. Через вызов в методе абстрактного класса NotImplementedError ============================================
В методе абстрактного класса прописать raise NotImplementedError. 
При попытке вызвать такой метод в объекте класса-наследника без предварительного переопределения будет ошибка.

class Fruit:

    def some_method(self):
        raise NotImplementedError


class Apple(Fruit):
    pass


obj = Apple()
obj.some_method()              # NotImplementedError

# ================================================================================================================
# TODO ИСПОЛЬЗОВАНИЕ АБСТРАКТНОГО КЛАССА ДЛЯ ГРУППИРОВКИ
# ================================================================================================================
# Абстрактные классы можно использовать для группировки разных конкретных классов, которые можно обрабатывать схожим образом.
# Для этого класс нужно зарегистрировать.

FooAbstrsact.register(SomeClass)












class Cat:
    """Строка документации класса"""

    name = 'bob'                    # атрибут класса - доступен каждому экземпляру
    # emp_count = 0                   # счетчик созданных объектов

    # def __init__(self, color):      # color - атрибут экземпляра, получаемый при создании
    #     self.color = color
    #     Cat.emp_count += 1          # увеличит счетчик созданных объектов на 1

    def print_name(self):
        return self.name

obj = Cat()

print(Cat.__module__)


# Cat.__name__              # имя класса
# Cat.__module__            # имя модуля, в котором определяется класс __main__



# print(Cat.__dict__)
# {'__module__': '__main__', '__doc__': 'Строка документации класса', 'name': 'bob', '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>}

print(dir(Cat))
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

# __dict__
# __dir__
# __sizeof__
# __hash__
# __doc__
# __class__
# __init__
# __init_subclass__
# __new__
# __weakref__

# __str__
# __repr__

# __setattr__
# __getattribute__
# __delattr__
# __format__

# __module__
# __eq__
# __ne__
# __ge__
# __gt__
# __le__
# __lt__

# __subclasshook__
# __reduce__
# __reduce_ex__



    # __dict__ — словарь, содержащий пространство имен класса.
    # __doc__ — строка документации класса. None если, документация отсутствует.
    # __name__ — имя класса.
    # __module__ — имя модуля, в котором определяется класс. Этот атрибут __main__ в интерактивном режиме.
    # __bases__ — могут быть пустые tuple, содержащие базовые классы, в порядке их появления в списке базового класса.



89===
Метод __new__() – это метод класса, который вызывается
для создания экземпляра. Метод __init__() инициализирует атрибуты объ-
екта и вызывается сразу же после создания этого объекта. Метод __del__()
вызывается перед уничтожением объекта.


Метод __hash__() определяется в объектах,
которые должны предоставлять возможность использовать их в качестве
ключей словаря.Он должен возвращать одно и то же целое число для объ-
ектов, которые при сравнении признаются эквивалентными.


не должен определяться в изменяемых объектах; любые изме-
нения в объекте будут приводить к изменению его хеша, что приведет к не-
возможности обнаружения объекта в словаре.





















