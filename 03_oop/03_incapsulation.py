# ================================================================================================================
# INCAPSULATION
# ================================================================================================================
ОТ СЕБЯ: любой объект создающий свой неймспейс можно назвать капсулой.

Инкапсуляция - объединение данных и методов работы с ними в один объект.
Инкапсуляция нужна для сокрытия атрибутов и методов, а также для избегания конфликтов имен атрибутов и методов между экземплярами базовых и производных классов. 
Полноценного сокрытия из коробки в питоне нет. Можно снизить заметность переопределив __getattribute__ и __dir__.


class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __getattribute__(self, attr):
        if attr: 
            return 'Secret'

    def __dir__(self):
        return []

    
p = Point(5, 10)

print(p.x)                   # Secret
print(p.__dict__)            # Secret
print(dir(p))                # []

    
p = Point(5, 10)

print(p.x)                   # Secret
print(p.__dict__)            # Secret

# ================================================================================================================
# PUBLIC, PROTECTED, PRIVATE, GETTER, SETTER
# ================================================================================================================
Класс и его экземпляры могут содержать только данные(атрибуты) и методы(функции), привязанные к переменным.
В ООП Питона есть 3 варианта доступности переменных:

# 1 === public
Можно использовать везде.

# 2 === _protected 
Доступ к защищенным переменным разрешен только внутри класса. 
Вне класса возможно получить доступ, НО это будет нарушение соглашения об использовании. Так нельзя делать.

# 3 === __private 
Разрешено использовать только внутри класса. 

Обращение к приватной переменной вне класса должно осуществляться либо через геттеры и сеттеры, либо через свойства.

При нарушении соглашения доступ возможен через obj._SomeClass__private и SomeClass._SomeClass__private. 
Префикс класса в имени переменной позволяет избежать конфликтов имен в классах наследниках(такую переменную нельзя случайно переопределить в наследнике).

Приватные перемменные, определенные в базовом классе, будут иметь префикс имени базового класса и будут присутствовать внутри пространства имен класса наследника-инициализатора. Для их использования в наследниках и вне класса можно создать в базовом классе публичный геттер.


# ===== Геттер
Метод для получения значений приватных переменных.

# ===== Сеттер
Метод для установки значений приватных переменных. 
Сеттеры могут выполнять функцию проверки получаемых значений по типу и значению, обрабатывать исключения.


class MyClass:

    some_class_attr = 'Hello World'

    def __init__(self, id, name, age):
        self.id = id                   # public
        self._name = name              # protected
        self.__age = age               # private
              

    # getter - вернет значение приватного атрибута
    def getAge(self):
        return self.__age   
        
    # setter - устанавливает значение приватного атрибута, проверив тип принимаемого значения
    def setAge(self, x):
        if isinstance(x, int) and (0 < x < 100):
            self.__age = x
        else:
            print('Возраст должен быть int')


# словарь класса MyClass.__dict__
{'__module__': '__main__', 'some_class_attr': 'Hello World', '__init__': <function MyClass.__init__ at 0x7f90e276c940>, 'getAge': <function MyClass.getAge at 0x7f90e276c9d0>, 'setAge': <function MyClass.setAge at 0x7f90e276ca60>,
 '__dict__': <attribute '__dict__' of 'MyClass' objects>, '__weakref__': <attribute '__weakref__' of 'MyClass' objects>, '__doc__': None}


obj = MyClass(1, 'Ivan', 30)

print(obj.getAge())       # 30
obj.setAge(40)            
print(obj.getAge())       # 40
obj.setAge('some string') # Возраст должен быть int

# словарь объекта obj.__dict__
{'id': 1, '_name': 'Ivan', '_MyClass__age': 40}


# ============================================================================================
# PROPERTY (Объекты-свойства) и МЕТОДЫ АТРИБУТОВ, __SLOTS__
# ============================================================================================

# === @property 
Свойства экземпляра класса - тип атрибута(по сути функция), которая вычисляется только 1 раз.
Обращение к свойству происходит как к простому атрибуту - без ().
Это более удобная альтернатива геттерам и сеттерам - вызов операций с атрибутом происходит через 1 имя свойства.
Свойства перехватывают операции по изменению и удалению атрибута @name_attr.setter или @name_attr.deleter.


# ===== Методы работы с атрибутами:

__setattr__(self, key, value)
# вызывается при изменении атрибута key класса
# метод имеет приоритет над __set__()

__getattribute__(self, item)
# вызывается первым при вызове атрибута
# если вернет значение - далее ничего не вызывается, если нет значения - вызовет __getattr__

__getattr__(self, item)
# вызывается после __getattribute__ если был вызов несуществующего атрибута

__delattr__(self, item)
# вызывается при удалении атрибута item (не важно: существует он или нет)


__slots__ = []
    # список разрешенных имен атрибутов в экземплярах класса, иначе AttributeError
    # атрибут __slots__ уменьшает расходы памяти(удаляется __dict__), ускорет доступ к атрибутам - они хранятся в массиве.
    # каждый атрибут слота на самом деле является объектом дескриптора
    # дескриптор знает как работать с арибутом с помощью индекса массива
    # в __slots__ нельзя указывать атрибуты класса, например WIDTH - иначе ошибка 
    # объявлять определенный слот в дереве наследования необходимо только один раз, иначе TypeError.

class PointProperty:

    # атрибут класса
    WIDTH = 100  

    # разрешает экземплярам класса иметь только следующие атрибуты:
    __slots__ = ["__x", "__y", "__private_attr"]

         
    # конструктор экземпляров
    def __init__(self, x, y):
        self.__x = x
        self.__y = y
        self.__private_attr = 'I am private attr'
        

    # приватный метод
    # этот конкретный метод не работает с экземпляром и классом, поэтому self и cls ему не требуется
    def __checkValue(x):
        """метод проверки атрибута на тип"""
        if isinstance(x, int) or isinstance(x, float):
            return True
        return False

    # геттер свойства
    @property
    def coordX(self):
        return self.__x

    # сеттер свойства
    @coordX.setter
    def coordX(self, x):
        if PointProperty.__checkValue(x):
            self.__x = x
        else:
            raise ValueError('bad data')

    # делитер свойства
    @coordX.deleter
    def coordX(self):
        print('del')
        del self.__x

    # ==== МЕТОДЫ АТРИБУТОВ ======================================================
    
    # метод для установки значения атрибута
    def __setattr__(self, key, value):
        """Метод запрещает установку и изменение атрибута"""
        if key == "WIDTH":
            raise AttributeError("Set WIDTH not allowed")
        else:
            # менять value можно только через __dict__[key]
            self.__dict__[key] = value

    # метод для получения значения атрибута
    def __getattribute__(self, item):
        """Метод запрещает показ приватного атрибута"""
        if item == '_PointProperty__private_attr':
            raise ValueError('Сработал __getattribute__: Private attribute')
        else:
            return object.__getattribute__(self, item)

    # метод для получения значения атрибута если ранее при поиске получа ошибка AttributeError
    def __getattr__(self, item):
        """Срабатывает при обращении к несуществующему атрибуту"""
        print("Сработал __getattr__: "+item)

    # метод для удаления атрибута
    def __delattr__(self, item):
        """Срабатывает при удалении атрибута"""
        print("Сработал __delattr__ :"+item)


obj = PointProperty(5,  10)
print(obj.coordX)                    # 5 Сработал __getattribute__: coordX

obj.coordX = 55
print(obj.coordX)                    # 55

# obj.WIDTH = 555                      # AttributeError: Set WIDTH not allowed
# obj._PointProperty__private_attr     # ValueError: Private attribute

obj.NO_ATTR                          # Сработал __getattr__: NO_ATTR
del obj.coordX                       # Сработал __delattr__ :coordX

# если не использовать декоратор @property, то можно задать свойство так:
# coordX = property(__getcoordX, __setcoordX, __delcoordX) (методы в скобках нужно предварительно создать)



# ============================================================================================
# DESCRIPTOR
# ============================================================================================
ОТ СЕБЯ: Дескриптор - специальный объект, который заменяет собой значение атрибута в главном объекте и реализует методы для работы со словарем __dict__ главного объекта, передавая ключ = имени атрибута

# === ПРОТОКОЛ ДЕСКРИПТОРА
Дескриптор-класс содержит хотя бы 1 из методов: __get__(), __set__() и __delete__().

В Питоне есть 2 вида дескрипторов: data descriptor и non-data descriptor(может иметь только метод __get__()). Попытка переписать non-data descriptor удалит его и создаст простой атрибут.

Если словарь экземпляра содержит запись с тем же именем, что и дескриптор данных, то дескриптор данных имеет приоритет. Если словарь экземпляра содержит запись с тем же именем, что и дескриптор без данных, то уже запись будет имеет приоритет.

# === ДЛЯ ЧЕГО НУЖЕН ДЕСКРИПТОР
Валидация данных при присваивании значений атрибуту(проверка типа, значений и тп), обработка исключений...
Запрет на получение данных атрибута.
Дескриптор избавляет от необходимости создавать много геттеров, сеттеров или свойств для каждого атрибута(когда их много).

# === КАК СОЗДАТЬ ДЕСКРИПТОР
Создать класс-дескриптор с реализацией одного или нескольких методов:__get__(), __set__() и __delete__().

Чтобы создать дескриптор данных только для чтения, определите как __get__(), так и __set__() с методом __set__(), вызывающим исключение AttributeError при вызове. Определение метода __set__() с raise, достаточно, чтобы сделать его дескриптором данных.

В классе главного объекта определить пременную с объектом-дескриптором. ВАЖНО: Дескриптор может определяться только на уровне класса, его нельзя добавить в объект.

Имя атрибута объекта должно отличаться от имени, используемого самим дескриптором в классе ("__" + name).
Если к классе есть дескрипторы, а в объекте атрибуты с одинаковыми именами, то приоритет вызова будет отдан дескриптору.

На протоколе дескриптора основаны: свойства, связанные методы, статические методы и методы классов!

class CoordValue:

    # В Питоне 3.6+ метод создает переменную с именем атрибута класса, которому объект дескриптора присваивается
    # owner    <class '__main__.Point'> - класс в котором определен дескриптор(не используется здесь, но нужен по протоколу)
    # name     coordX                   - имя переменной объекта-дескриптора
    def __set_name__(self, owner, name):           
        self.__name = name

             
    # геттер
    # instance   <__main__.Point object at 0x7f6fd81162b0> - ссылка на объект Point, в котором вызван метод дескриптора
    # owner      <class '__main__.Point'>
    def __get__(self, instance, owner):
        return instance.__dict__[self.__name]      # берет значение из словаря объекта Point

    # сеттер
    def __set__(self, instance, value):
        instance.__dict__[self.__name] = value     # записывает в словарь объекта Point "имя дескриптора": "значение" 

    # делиттер
    def __delete__(self, instance):               
        del instance.__dict__[self.__name]


class Point:

    # атрибуты-дескрипторы
    # дескрипторы могут быть определены только на уровне класса!
    coordX = CoordValue()
    coordY = CoordValue()

    def __init__(self, x=0, y=0):
        self.coordX = x                # self.coordX = вызовет __set__ у дескриптора, он вернет value из словаря экземпляра
        self.coordY = y                # при совпадении имен приоритет отдается всегда дескриптору


d = Point(1, 2)
