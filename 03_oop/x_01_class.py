

# ===========================================================================================
# АБСТРАКТНЫЕ КЛАССЫ
# ===========================================================================================
Абстрактные базовые классы реализуют механизм организации объектов в иерархии, позволяющий утверждать о наличии требуемых методов. Абстрактный класс не может использоваться для создания экземпляров, но определяет, какие свойства и методы должны быть реализованы в подклассах.
# 1 вариант создания
from abc import ABCMeta, abstractmethod, abstractproperty
# 2 вариант создания
В методах обстрактного класса прописать raise NotImplementedError - это обяжет реклизовать эти методы в наследниках.
# абстрактные классы можно использовать для группировки классов. Для этого класс нужно зарегистрировать.
FooAbstrsact.register(SomeClass)


# ===========================================================================================
# МЕТАКЛАССЫ
# ===========================================================================================
Метакласс – это объект, который знает, как создавать классы и управлять ими.
Одно из основных применений метаклассов - проверка и сбор информации об определениях классов.
Метаклассы могут менять поведение классов.
Метакласс определяется как “класса класса”. Любой класс, экземпляры которого являются сами классы, является метаклассом.





class Cat:
    """Строка документации класса"""

    name = 'bob'                    # атрибут класса - доступен каждому экземпляру
    # emp_count = 0                   # счетчик созданных объектов

    # def __init__(self, color):      # color - атрибут экземпляра, получаемый при создании
    #     self.color = color
    #     Cat.emp_count += 1          # увеличит счетчик созданных объектов на 1

    def print_name(self):
        return self.name

obj = Cat()

print(Cat.__module__)


# Cat.__name__              # имя класса
# Cat.__module__            # имя модуля, в котором определяется класс __main__



# print(Cat.__dict__)
# {'__module__': '__main__', '__doc__': 'Строка документации класса', 'name': 'bob', '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>}

print(dir(Cat))
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

# __dict__
# __dir__
# __sizeof__
# __hash__
# __doc__
# __class__
# __init__
# __init_subclass__
# __new__
# __weakref__

# __str__
# __repr__

# __setattr__
# __getattribute__
# __delattr__
# __format__

# __module__
# __eq__
# __ne__
# __ge__
# __gt__
# __le__
# __lt__

# __subclasshook__
# __reduce__
# __reduce_ex__



    # __dict__ — словарь, содержащий пространство имен класса.
    # __doc__ — строка документации класса. None если, документация отсутствует.
    # __name__ — имя класса.
    # __module__ — имя модуля, в котором определяется класс. Этот атрибут __main__ в интерактивном режиме.
    # __bases__ — могут быть пустые tuple, содержащие базовые классы, в порядке их появления в списке базового класса.



89===
Метод __new__() – это метод класса, который вызывается
для создания экземпляра. Метод __init__() инициализирует атрибуты объ-
екта и вызывается сразу же после создания этого объекта. Метод __del__()
вызывается перед уничтожением объекта.


Метод __hash__() определяется в объектах,
которые должны предоставлять возможность использовать их в качестве
ключей словаря.Он должен возвращать одно и то же целое число для объ-
ектов, которые при сравнении признаются эквивалентными.


не должен определяться в изменяемых объектах; любые изме-
нения в объекте будут приводить к изменению его хеша, что приведет к не-
возможности обнаружения объекта в словаре.





















