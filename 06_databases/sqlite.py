# https://habr.com/ru/post/321510/
# http://python-3.ru/category/sqlite
# https://www.youtube.com/watch?v=byHcYRpMgI4&t=2421s

https://pythonru.com/osnovy/sqlite-v-python
"""
Типы данных SQLite:
    NULL – значение NULL;
    INTEGER – целочисленный тип (занимает от 1 до 8 байт);
    REAL – вещественный тип (8 байт в формате IEEE);
    TEXT – строковый тип (в кодировке данных базы, обычно UTF-8);
    BLOB (двоичные данные, хранятся «как есть», например, для небольших изображений).

База данных SQLite не предназначена для проектов, предъявляющих требования к защите данных и разграничению прав доступа для нескольких пользователей. Не поддерживает сетевое взаимодействие.

Запись данных может осуществлять только один поток или процесс в один момент времени. А вот на чтение таких ограничений нет. Если к базе установлено несколько соединений и одно из них осуществляет модификацю базы, то база SQLite залочивается до завершения (метод соединения .commit()) или отмены (метод соединения .rollback()) транзакции.

Стандартный курсор забирает все данные с сервера сразу, не зависимо от того, используем мы .fetchall() или .fetchone()

Для большей устойчивости программы (особенно при операциях записи) можно оборачивать инструкции обращения к БД в блоки «try-except-else» и использовать встроенный в sqlite3 «родной» объект ошибок.

Каждая таблица SQLite содержит скрытое поле rowid, хранящее уникальный идентификатор записи.

Защита от SQL-инъекций:
    Не использовать в SQL запросе конкатенацию строк (+)
    Не использовать в SQL запросе интерполяцию параметра в строке (%)

C подставновкой по порядку на места знаков вопросов:
    В PostgreSQL (UPD: и в MySQL) вместо знака '?' для подстановки используется: %s
    cursor.execute("SELECT Name FROM Artist ORDER BY Name LIMIT ?", ('2'))

    И с использованием именнованных замен:
    cursor.execute("SELECT Name from Artist ORDER BY Name LIMIT :limit", {"limit": 3})

"""

# ===== Download Fake SQL DATA =======================================================================
# https://github.com/lerocha/chinook-database
# https://github.com/lerocha/chinook-database/blob/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite


cursor.execute()                      # Выполнить команду SQL
cursor.executemany()                  # Выполнить команду SQL для списка параметров
cursor.executescript()                # Выполнить несколько операторов SQL

cursor.fetchone()                     # Получить одну строку с результатом запроса
cursor.fetchmany()                    # Получить список из нескольких строк с результатом запроса
cursor.fetchall()                     # Получить список всех строк с результатом запроса
cursor.arraysize                      # Получить/установить количество строк для метода cursor.fetchmany()

cursor.lastrowid                      # Получить ID последней измененной строки
cursor.description                    # Получить имена столбцов последнего запроса
cursor.rowcount                       # Получить количество выбранных строк

cursor.connection                     # Получить объект соединения с базой
connection.close()                    # Закрыть соединение


# ====================================================================================================
# CREATE DB, CONNECT AND CURSOR
# ====================================================================================================

import sqlite3

with sqlite3.connect(
    'Chinook_Sqlite.sqlite',                             # допустимые расширения базы *.db, *.db3, *.sqlite и *.sqlite3
    # isolation_level=None                               # делать коммит при каждом запросе
) as conn:
# with sqlite3.connect(':memory:') as conn:              # create db in memory
    cur = conn.cursor()                                  # with автоматически закрывает соединение даже при ошибке.

Когда контекстный менеджер завершает свою работу, он автоматически выполняет два метода:
    con.commit() – применение всех изменений в таблицах БД
    con.close() – закрытие соединения с БД.
# ====================================================================================================
# CREATE AND DELETE TABLE
# ====================================================================================================

cur.execute("""CREATE TABLE IF NOT EXISTS users (        # IF NOT EXISTS - если нет такой таблицы
    name TEXT NOT NULL,
    sex INTEGER,
    old INTEGER,
    score INTEGER
)""")

cur.execute("DROP TABLE users")
# ====================================================================================================
# SELECT
# ====================================================================================================

# Делаем SELECT запрос к базе данных, используя обычный SQL-синтаксис
cur.execute("SELECT Name FROM Artist ORDER BY Name LIMIT 3")

# Получаем результат сделанного запроса
results = cur.fetchall()
print(results)   # [('A Cor Do Som',), ('Aaron Copland & London Symphony Orchestra',), ('Aaron Goldberg',)]

for row in cur.fetchall():              # сформирует полный список
    print(row)

for row in cur:                         # не формирует список, итерирует по одному
    print(row)

# ====================================================================================================
# INSERT INTO
# ====================================================================================================

# Делаем INSERT запрос к базе данных, используя обычный SQL-синтаксис
cursor.execute("insert into Artist values (Null, 'A Aagrh!') ")

# Если мы не просто читаем, но и вносим изменения в базу данных - необходимо сохранить транзакцию
conn.commit()

# безопасная передача аргументов
t = ('RHAT',)
cursor.execute('SELECT * FROM stocks WHERE symbol=?', t)
# ====================================================================================================
# DELETE FROM
# ====================================================================================================



# ====================================================================================================
# row_factory
# ====================================================================================================
"""
Позволяет брать метаданные из запроса и обращаться в итоге к результату, например по имени столбца.
По сути — callback для обработки данных при возврате строки. Да еще и полезнейший cursor.description, где есть всё необходимое.
"""

def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d

con = sqlite3.connect(":memory:")
con.row_factory = dict_factory
cur = con.cursor()
cur.execute("select 1 as a")
print(cur.fetchone()["a"])



# ====================================================================================================
# MAKE DUMP
# ====================================================================================================
# export
with open("sql_dump.sql", "w") as f:
        for sql in con.iterdump():
            f.write(sql)

# import
with open("sql_dump.sql", "r") as f:
        sql = f.read()
        cur.executescript(sql)