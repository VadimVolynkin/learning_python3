
# ==================================================================================
# ТРЕБОВАНИЯ ПО ACID
# ==================================================================================
Требования к транзакционной системе, обеспечивающие наиболее надёжную и предсказуемую её работу. 
В базах данных, следующих принципу ACID, данные остаются целостными и консистентными, несмотря на любые ошибки и сбои.

ТИПЫ СБОЕВ:

# Ошибка транзакции
Может произойти из-за некорректных входных данных или любых других нарушений целостности. 
Возникает в результате тайм-аута или в результате deadlock.

# Системный сбой
Может произойти из-за ошибки в коде СУБД, либо аппаратного сбоя.

# Медийные сбои
Может произойти, когда запись или чтение из хранилища невозможны (например сбой в работе жёсткого диска, либо ошибки в работе операционной системе). Эти ошибки возникают намного реже, чем первые 2 типа.


# ===== ATOMICITY(Атомарность)
Будут выполнены все операции транзакции или ничего.
В случае падения хоть одной производиться откат(rollback).
Счётчики, индексы и другие внутренние структуры после отката могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.


# ===== CONSISTENCY(Согласованность)
Данные будут корректны(целостны) в соотвествии со всеми правилами, ограничениями, каскадами и триггерами, применёнными к БД.
Каждая успешно завершившаяся транзакция(EOT — end of transaction) по определению фиксирует только допустимые результаты.
Это условие является необходимым для поддержки четвёртого свойства. 

На практике сошласованность - более широкое понятие.
В банковской системе может существовать требование: равенство суммы списываемой с одного счёта, сумме, зачисляемой на другой. 
Списание и зачисление будут двумя разными операциями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако при выполнении требования изоляции эта несогласованность не будет видна другим транзакциям.
Атомарность гарантирует, что транзакция будет полностью завершена или откат, поэтому промежуточная несогласованность является скрытой. 

# ===== ISOLATION(Изолированность)
Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. 

Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).


# ===== DURABILITY(Долговечность)
Если БД сообщила об успешном выполнении транзакции, то данные останутся в ней навсегда, даже если база упадет сразу после этого.


# ==================================================================================
# ПРОБЛЕММЫ ПАРАЛЛЕЛЬНОГО ДОСТУПА ПРИ ПРИ ТРАНЗАКЦИЯХ
# ==================================================================================

# ===== ПОТЕРЯННОЕ ОБНОВЛЕНИЕ(lost update)
При одновременном изменении 1 блока данных разными транзакциями теряются все изменения, кроме последнего.

Пример ошибки:
Обе транзакции одновременно читают текущее состояние поля = 50
Обе транзакции прибавляют к полю 20 и 25. Резульат: 70 и 75.
Транзакции записывают результат вычислений, при этом последняя вычесленная транзакция перезаписывает результат уже записанной первой. 
Состояние поля: 75 вместо 95

Правильный вариант: 
Транзакция1 = читает 50, прибавляет 20, записывает 70
Транзакция2 = читает 70, прибавляет 25, записывает 95


# ===== ГРЯЗНОЕ ЧТЕНИЕ(dirty read)
Чтение данных, добавленных или изменённых транзакцией, которая впоследствии откатится.

Пример ошибки:
Транзакция1 считала 50, прибавила 20, записала 70 и продолжила свою работу...
Транзакция2 считала 70
Транзакция1 упала, сработал откат на 50
Состояние поля: 50, но транзакция2 получила данные что состояние поля = 70


# ===== НЕПОВТОРЯЮЩЕЕСЯ ЧТЕНИЕ(non-repeatable read)
При повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

Пример ошибки:
Транзакция1 считала 50 и продолжила работу...
Транзакция2 записала 70
Транзакция1 повторно считала повторно поле, но получила 70


# ===== ФАНТОМНОЕ ЧТЕНИЕ(phantom reads)
Одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. 
Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. 
В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.
Разница с неповторяющимся чтением в причине ошибки - появление новых данных(фантомных данных).

Пример ошибки:
Транзакция1 суммирует поля таблицы(например цены) и продолжет работу...
Транзакция2 вставляет новую строку
Транзакция1 повторно суммирует поля, но результат отличается. 


# ==================================================================================
# УРОВНИ ИЗОЛЯЦИИ
# ==================================================================================
Уровень изоляции транзакций СУБД - степень защиты от всех или некоторых видов несогласованностей данных при параллельном выполнении транзакций. 
Стандарт SQL-92 определяет 4 уровня изоляции: первый - самый слабый, последний - самый сильный, каждый последующий включает все предыдущие.
СУБД могут дополнительно иметь собственные уровни изоляции.

# ===== READ UNCOMMITTED(чтение незафиксированных данных)
Самый низкий уровень защиты.
Защита от: потерянное обновление.

Способ реализации:
Транзакция изменяющая поле блокирует доступ к нему других изменяющих транзакций.
Это приведет к последовательному выполнению изменения.
Транзакции выполняющие только чтение поля не блокируются.

# ===== READ COMMITTED(чтение фиксированных данных)
Защита от: потерянное обновление, грязное чтение.
Большинство промышленных СУБД: Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют этот уровень. 

Есть 2 подхода к реализации:

# 1. Блокирование читаемых и изменяемых данных
Транзакция1 блокирует изменяемые данные до свого завершения от читающей Транзакции2, работающей на уровне read committed или выше.
Транзакция2 блокирует читаемые данные до завершения SELECT. Таким образом возможна проблема «неповторяющегося чтения», если у Транзакции1 будет откат.

# 2. Сохранение нескольких версий параллельно изменяемых строк
Транзакция1 изменяет строку и продолжает работать(СУБД создает версию2 строки, с которой Транзакция1 продолжает работать)
Транзакция2 читает версию1 строки.

Этот подоход быстрее - он предотвращает блокировки, но требует больше памяти на хранение версий строк.

Возможна ситуация, когда несколько параллельных транзакций произведут несогласованные изменения одних данных(блокировки отсутствуют, ничто не мешает это сделать). 
Первая завершенная транзакция сохранит изменения в основной БД, остальные уже не смогут(это приведёт к потере обновления первой). 
В такой ситуации СУБД откатит остальные транзакции и выдаст сообщение об ошибке «Запись уже изменена».


# ===== REPEATABLE READ(повторяющееся чтение)
Степень параллелизма ниже, чем при READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.

Транзакция1 блокирует доступ ко все данным с которыми работают ее инструкции до своего завершения.
Транзакция2 не может считать строки с которыми работает Транзакция1.
Транзакция3 сможет вставить новую строку, поэтому при повторном считывании инструкции Транзакцией 1 будут получены фантомные данные.


# ===== SERIALIZABLE(упорядочиваемость)
Самый сильный уровень защиты - решает все 4 проблемы.
Транзакции полностью изолируются друг от друга, как будто параллельных транзакций не существует. 




