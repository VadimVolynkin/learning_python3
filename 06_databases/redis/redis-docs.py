# https://redis.io/documentation

Redis - хранилище данных в памяти с открытым исходным, используемое в качестве базы данных, кеша и брокера сообщений. 
Redis означает Remote Dictionary Service(служба удаленного словаря).

Его используют в:
    Кеширование данных
    Чаты и системы обмена сообщений
    Диспетчеризация любых данных
    Различные очереди задач
    Мониторинг различных данных



# запуск редис сервера на локальной машине с конфигом
redis-server /etc/redis/6379.conf

# ==================================================================================
# REDIS TYPES
# https://redis.io/topics/data-types
# ==================================================================================

# === Ключи
Ключи Redis всегда являются строками string. 
Ключи безопасны для бинарного кода - можно использовать хоть JPEG. Пустая строка также является допустимым ключом.
Ключи нужно стараться делать хорошочитаемыми, например "комментарий: 1234: reply-to".
Макс. размер - 512 МБ.
Редис создаетпоследовательность при попытке добавить ключ и удаляет если последовательность пуста.

# === Значения
Значения Redis могут относиться к различным типам данных.
Макс. размер - 512 МБ.

# === Префиксы
Префиксы - соглашение для создания пространства имен внутри базы данных Redis.  someprefix:56854717

# === Общие команды для всех типов
EXISTS             # существует ключ или нет - вернет 1 или 0
DEL                # удалит ключ и вернет 1 или 0
TYPE               # вернет тип значения ключа

# === Время жизни ключа
Можно установить с точностью до секунд или миллисекунд, но разрешение всегда составляет 1 миллисекунду.
Дата истечения реплицируется и сохраняется на диске, поэтому время истекает даже если сервер Redis остановлен

# способ 1
SET key 424242     # устанавливает значение
EXPIRE key 5       # устанавливает для ключа время жизни 5 сек
TTL key            # вернет оставшееся время жизни ключа
PEXPIRE key 500    # устанавливает время жизни в милисекундах           
PTTL               # вернет оставшееся время жизни ключа в милисекундах
PERSIST            # удаляет для ключа время жизни, делая его снова вечным

# способ 2
SET key 424242 EX 10      # устанавливает время жизни в секундах
SET key 424242 PX 500     # устанавливает время жизни в милисекундах


# ===== BINARY_SAFE STRINGS
Бинарно-безопасные строки.
APPEND, BITCOUNT, BITFIELD, BITOP, BITPOS, INCRBYFLOAT, MSETNX, PSETEX, SETEX, SETNX, STRLEN

SET                # устанавливает значение 1 ключа
GET                # получает значение 1 ключа

MSET               # устанавливает значение нескольких ключей  
MGET               # получение значений нескольких ключей

GETSET             # устанавливает новое значение и возвращает старое

INCR               # увеличивает на 1 атомарно
DECR               # уменьшает на 1 атомарно

INCRBY             # увеличивает с шагом    
DECRBY             # уменьшает с шагом

SETBIT
GETBIT

SETRANGE
GETRANGE

# ===== HASHES
Карты, состоящие из полей, связанных со значениями. И поле, и значение являются строками. 
Небольшие хеши с небольшими значениями кодируются особым образом - очень эффективны по расходу памяти.

Команды для работы с хешами начинаются с Н, такие как HSET, HGET, HMSET
HDEL, HEXISTS, HINCRBYFLOAT, HKEYS, HLEN, HSCAN, HSETNX, HSTRLEN, HVALS

# устанавливает 3 пары поле-значение в ключ user:1000
HSET user:1000 name "vadim"           # 1
HSET user:1000 age "30"               # 1
HSET user:1000 town "moscow"          # 1

# получение 1 поля
HGET user:1000 username

# хеши редис похожи на вложенный словарь питона
# аналог данных в питоне
data = {
    "user:1000": {
        "name": "vadim",
        "age": "30",
        "town": "moscow"
    }
}

# установка множества пар поле-значение сразу
HMSET user:1000 name vadim age 30 town moscow

# получение значений нескольких полей
hmget user:1000 name age no-such-field

# получение всех пар
HGETALL user:1000
1) "name"
2) "vadim"
3) "age"
4) "30"
5) "town"
6) "moscow"

# увеличивает с шагом 10
HINCRBY user:1000 age 10     

# ===== SETS
Коллекции уникальных, несортированных строк.

Команды для работы с множествами начинаются с S
SDIFF, SDIFFSTORE, SINTERSTORE, SMOVE, SREM, SSCAN, SUNION, 

# добавление элементов в множество
SADD myset 1 2 3

# получение элементов может быть в любом порядке
SMEMBERS myset
1) "1"
2) "2"
3) "3"

# проверка наличия элемента
SISMEMBER myset 3             # вернет 1 или 0

# список всех объектов с тегами 1, 2, 10 и 27 вместе
SINTER tag:1:news tag:2:news tag:10:news tag:27:news

# вернет случайный элемент и удаляет его
SPOP myset

# вернет случайный элемент и не удалит его
SRANDMEMBER myset

# вернет 2 случайных и не удалит
SRANDMEMBER myset 2

# объединение нескольких сетов  и сохоаняет в 1 новый
SUNIONSTORE newset myset myset2

# делает копию одного сета
SUNIONSTORE newset myset

# количество элементов в наборе
SCARD myset

# ===== SORTED SETS
Похожи на сеты и хеши. Все элементы уникальны и имеют свою оценку.
Добавление элемента - O(log(N)). Отсортированные наборы подходят при большом количестве обновлений.
похожие на наборы, но где каждый строковый элемент связан со значением с плавающей запятой, называемым оценкой. Элементы всегда отсортированы по их количеству очков, поэтому, в отличие от Sets, можно получить диапазон элементов (например, вы можете спросить: дайте мне 10 лучших или 10 последних).

SCARD дает количество элементов в значении set, соответствующего данному ключу.

# добавление в список
ZADD hackers 1916 "Claude Shannon"
ZADD hackers 1969 "Linus Torvalds" 1912 "Alan Turing"

# срез вернет значения
ZRANGE hackers 0 -1

# обратный срез
ZREVRANGE hackers 0 -1

# вернет срез с оценками
zrange hackers 0 -1 WITHSCORES

# вернет значения с оценкой ниже 1950
ZRANGEBYSCORE hackers -inf 1950

# удалит между 1940 1960, вернет количество удаленных
ZREMRANGEBYSCORE hackers 1940 1960

# вернет индекс элемента
ZRANK hackers "Alan Turing"

# лексикографические диапазоны
# могут быть включающими или исключающими (в зависимости от первого символа)
# бесконечная строка и бесконечная минус бесконечность указываются соответственно строками + и -
zadd hackers 0 "Alan Kay" 0 "Sophie Wilson" 0 "Richard Stallman"
ZRANGEBYLEX hackers [B [P

ZREVRANGEBYLEX

ZREMRANGEBYLEX

ZLEXCOUNT

# ===== LITS
Списки Редис - связанные списки - коллекции строковых элементов, отсортированные по порядку вставки. 
Скорость добавления нового элемента в начало или конец постоянна и не зависит от количества элементов.
Скорость доступа пропорциональна индексу элемента - это работает медленнее, чем у индексированных списков. Для больших коллекций данных можно использовать отсортированные наборы(SORTED SETS).

Команды для работы со списками начинаются с L, R(LPOP,RPUSH), В (BLPOP — блокировка).
BRPOPLPUSH, LINDEX, LINSERT, LPUSHX, LREM, LSET, RPOPLPUSH, RPUSHX

LPUSH mylist A            # добавляет в начало
LPUSH mylist 45 92 54     # добавляет в начало несколько элементов сразу
RPUSH mylist B            # добавляет в конец
LRANGE mylist 0 -1        # вернет срез
LTRIM mylist 0 2          # удалит все вне диапазона

LPOP mylist               # удалит первый элемент и вернет его значение
RPOP mylist               # удалит последний элемент и вернет его значение

BLPOP tasks 5             # блокирует LPOP вызов если список пуст, ждет 5 сек и возвращает(nil). 
BLPOP tasks 0             # timeout = 0 - ждет бесконечно 
BLPOP tasks tasks2 50     # блокирует 2 списка, сработает если получит значение хоть в одном. Вернет массив с ключом списка. 
BRPOP tasks 5             # блокирует RPOP вызов если список пуст, ждет 5 сек и возвращает(nil)

LMOVE mylist myotherlist RIGHT LEFT         # чередующаяся очередь
BLMOVE                                      # блокирует если пусто

LLEN                                        # вернет количество элементов в списке

# ===== BIT ARRAYS(SIMPLY BITMAPS)
Это не тип данных, а набор битовых операций, определенных для типа String.
Битовые массивы (или просто растровые изображения): с помощью специальных команд можно обрабатывать строковые значения, такие как массив бит: вы можете устанавливать и очищать отдельные биты, подсчитывать все биты, установленные в 1, находить первый установленный или неустановленный бит, и так далее.
Подходят для установки до 232 различных бит.
Применение: Все виды аналитики в реальном времени. Хранение рациональной, но высокопроизводительной логической информации, связанной с идентификаторами объектов.

# === Битовые операции делятся на 2 группы: 

# 1. Однобитовые операции с постоянным временем, такие как установка бита на 1 или 0 или получение его значения

# установка бита
# команда автоматически увеличивает строку, если адресный бит выходит за пределы текущей длины строки
SETBIT key 10 1         # первый аргумент - номер бита, второй - значение 0 или 1

# считывание бита
# биты вне диапазона (адресация бита, выходящего за пределы строки, хранящейся в целевом ключе) всегда считаются равными нулю.
GETBIT key 10   

# 2. Операции с группами битов, например подсчет количества установленных битов в заданном диапазоне бит. (например, подсчет населения).

# выполняет побитовые операции между разными строками
# предусмотрены операции AND, OR, XOR и NOT
BITOP AND destkey srckey1 srckey2 srckey3 ... srckeyN

# выполняет подсчет населения, сообщая количество битов, равное 1
# может работать с байтовыми диапазонами строки
BITCOUNT key

# находит первый бит, имеющий указанное значение 0 или 1
# может работать с байтовыми диапазонами строки  BITPOS key bit [start [end]] 
BITPOS key 1 0 -1

# ===== HyperLogLogs(HLL)
Вероятностная структура данных используется для оценки мощности набора.
Для подсчета требуется максимум 12 Кбайт при стандартной ошибке менее 1%.

Можно работать как со строкой: GET для сериализации HLL и SET для десериализации обратно на сервер.

Каждый раз, когда вы видите новый элемент, вы добавляете его в счет с помощью PFADD.
Каждый раз, когда вы хотите получить текущее приближение уникальных элементов, добавленных с помощью PFADD, вы используете PFCOUNT. 


# ===== STREAMS
Потоки: коллекции записей, похожих на карты, которые предоставляют абстрактный тип данных журнала.


# ==================================================================================
# REDIS-CLI
# ==================================================================================
# команды не чувствительные к регистру

# запуск клиента и выход
redis-cli
quit

# очистка БД
FLUSHDB

# ===== REDIS CRUD

# create new single key or update
SET Croatia Zagreb                            # установка нового ключа Croatia
SET hello "hello world"                       # установка значения из нескольких слов

# create new multi key or update
MSET Lebanon Beirut Norway Oslo France Paris  # идут парами ключ значение через пробел

# retrieve single key
GET Croatia                                   # "Zagreb" - получения значения по ключу
GET Japan                                     # (nil) результат получения несуществующего ключа(аналог None в Python)

# retrieve multi keys
MGET Lebanon Norway Bahamas                   # 1) "Beirut" 2) "Oslo" 3) (nil)

# проверка существования ключа
EXISTS Norway                                 # 1
EXISTS Norway3434545                          # 0


# ===== TRANSACTIONS
# транзакция начинается с MULTI и заканчивается на EXEC:
MULTI
HINCRBY 56854717 quantity -1
HINCRBY 56854717 npurchased 1
EXEC


# ===== КОНВЕЙЕРЫ

# ===== СЕРИАЛИЗАЦИЯ
# ===== ШИФРОВАНИЕ
# ===== КОМПРЕССИЯ


# ===== ОПТИМИСТИЧЕСКАЯ БЛОКИРОВКА(optimistic locking)
# вызов функции (client) ищет изменения в данных, которые записываются в течение удержания блокировки
# если в это время происходит конфликт, вызываемая функция повторяет весь процесс заново
WATCH

# ==================================================================================
# REDIS CONFIG
# ==================================================================================
# /usr/local/etc/redis/redis.conf

port              6379 
daemonize         yes              # сервер будет работать в фоновом режиме
save              900 1            # делать снепшот каждые 900 секунд если есть хоть 1 изменение
save              300 10
save              60 10000
bind              127.0.0.1
tcp-keepalive     300
dbfilename        dump.rdb         # имя файла снепшота на диске
dir               ./               # сохранение в директории откуда был запуск редис сервера
rdbcompression    yes              # сжатие


# ==================================================================================
# REDIS DOCKER
# ==================================================================================
# dockerfile in this path

docker run redis
---------------------------------------------------------
sudo docker exec -it $(sudo docker run -d redis) redis-cli
quit
---------------------------------------------------------


