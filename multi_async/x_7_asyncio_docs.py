https://docs-python.ru/standart-library/modul-asyncio-python/
https://www.youtube.com/playlist?list=PLlWXhlUMyooawilqK4lPXRvxtbYiw34S8
https://webdevblog.ru/vypolnenie-neskolkih-odnovremennyh-http-zaprosov-s-python-asyncio/
"""
# ===== КАК РАБОТАЕТ ЦИКЛ В Asyncio ===========================================================================

1. Луп берет из очереди таск.
2. У корутины от этой таски вызывается метод step()
3. Корутина выполняет свой код. Если корутина вызывает другую корутину, то она останавливает свое выполнение и передает контроль выполнения в вызванную корутину. Отработав, вызванная корутина возвращает контроль делегирующей корутине, а та в свою очередь возвращает контроль в луп.
4. Потом луп берет слудующую задачу...
5. Когда событийный цикл доходит снова до первой задачи, то выполнение первой корутины продолжается с места остановки.

# ===== АСИНХРОННОСТЬ В Asyncio ===============================================================================

Асинхронный код состоит из 2 условий:
1. Любая конструкция языка, позволяющая передавать выполнение потока: замыкания, генераторы, корутины...
2. Событийный цикл, который решает какой код будет выполняться в тот или иной момент.

Асинхронные функции(корутины) должны запускаться в асинхронных функциях. Внутри асинхронных функций можно запускать синхронный код, но тогда будет блокировка. Смешивать асинхронный код с синхронным - плохая идея.

Асинхронные события происходят независимо друг от друга (не синхронизированно друг с другом), полностью в одном потоке.

В отличие от многопоточности, в асинхронных программах программист контролирует, когда и как происходит произвольное вытеснение, облегчая изоляцию и избегая условий гонки.

Компоненты Asyncio подразделяются на:
- API-интерфейсы высокого уровня (для написания программ)
- API-интерфейсы низкого уровня (для написания библиотек или сред на основе asyncio)

# ===== Awaitables, Async, и Await
Любой объект, который может прерывать свой процесс выполнения, называется awaitable.
Есть 3 ожидаемых объекта (awaitable) — coroutine, task и future:

= 1. КОРУТИНЫ
Функция с префиксом async. Сопрограммы в Python являются объектами, которые могут ждать результатов от сторонних сервисов или своей очереди выполнения.
Подпрограмма для добровольной упреждающей многозадачности: она активно уступает свои ресурсы другим подпрограммам и процессам, а не принудительно вытесняется ядром. В asyncio это так же называется awaiting.

= 2. TASK
Таски - контейнеры для корутин. Task - это сопрограмма, которая планируется для выполнения в будущем, как только это станет возможным.
Таски крутяться в лупе и сразу в момент вызова отдают заглушку-пустой результат, чтобы не блокировать поток выполнения.
Задача — это awaitable (ожидаемый) объект, который оборачивается вокруг подпрограммы (coroutine), предоставляя методы для контроля ее выполнения и запроса ее статуса.

Task может быть создан с помощью asyncio.create_task() или помещен в планировщик asyncio.gather().

= asyncio.create_task() вернет объект задачи. Создание задачи говорит циклу: «Иди и запусти эту coroutine (подпрограмму), как только сможешь».
Если вы ожидаете (await) задачу, выполнение текущей coroutine блокируется, пока эта задача не будет завершена.

= asyncio.gather(awaitables) — это удобный способ запланировать одновременное выполнение нескольких подпрограмм в качестве задач. Метод собирает объекты awaitable в группу и возвращает объект awaitable. Сбор имеет ряд особенностей:
1. Когда все собранные задачи завершены, их совокупные возвращаемые значения возвращаются в виде списка, упорядоченного в соответствии с порядком списка awaitable.
2. Любая собранная задача может быть отменена без отмены других задач.
Метод .cancel() запрашивает отмену задачи. Задача будет запланирована для отмены в следующем проходе цикла событий. Отмена не гарантируется: задание может быть выполнено до прохода цикла, и в этом случае отмены не будет.
3. Сам сбор может быть отменен, отменяя все задачи.

= FUTURE
future - объект уже запущенной сопрограммы с еще неполученными/промежуточными результатами.
future в asyncio — это низкоуровневый объект, который выполняет роль заполнителя для данных, которые еще не были рассчитаны или получены. Он может обеспечить пустую структуру для последующего заполнения данными и механизм обратного вызова, который срабатывает, когда данные готовы.


#  ===== Event Loops

В asyncio event loop (цикл обработки событий) управляет планированием и передачей ожидаемых объектов.
event loop требуется для использования awaitables. Каждая программа asyncio имеет как минимум один event loop. Можно иметь несколько event loop, но в Python 3.7 настоятельно рекомендуется использовать только один event loop.

Ссылка на работающий в данный момент объект цикла получается путем вызова asyncio.get_running_loop().

Канонической точкой входа в программу asyncio является asyncio.run(main()), где main () — подпрограмма (coroutine) верхнего уровня. asyncio.run() не может быть вызвана из существующего цикла событий.

Вызов asyncio.run() неявно создает и запускает event loop (цикл обработки событий). У объекта цикла есть много полезных методов, включая loop.time(), который возвращает число с плавающей запятой, представляющее текущее время, измеренное внутренними часами цикла.

Цикл событий запускает одну задачу за раз. Пока объект задачи Task ожидает готовности Future, цикл событий запускает другие задачи, обратные вызовы или выполняет операции ввода-вывода.

===== Sleeping

Подпрограмма asyncio.sleep(delay) используется для имитации блокировки ввода-вывода.


========================
# TODO stream, набор высокоуровневых сетевых примитивов для управления асинхронными событиями TCP.

lock, event, condition, асинхронные аналоги примитивов синхронизации, предусмотренных в модуле threading.

subprocess, набор инструментов для запуска асинхронных подпроцессов, таких как команды оболочки.

queue, асинхронный аналог модуля queue.

exception, для обработки исключений в асинхронном коде.

========================
асинхронный генератор
async for
async with  https://docs-python.ru/tutorial/sintaksis-async-await-python/
метод __await__()

await позволяет сопрограмме отдать контроль назад в главный цикл, который содержит порядок исполнения всех сопрограмм.

"""

# =========================================================================================================
import asyncio


async def my_coro(n):
    """A coroutine."""
    print(f"The answer is {n}.")


async def main():
    """The top-level coroutine."""
    # Создав задачу, вы запланировали ее запуск
    # по усмотрению цикла событий.
    mytask = asyncio.create_task(my_coro(42))
    # Если мы позже, выполним await программа останавливается
    # пока задача не будет завершена.
    await mytask

asyncio.run(main())


# ===== МЕТОДЫ В asyncio ===========================================================================

asyncio.run(coro, *, debug=False)
# coro - точка входа в асинхронную программу, debug=False - включение отладчика.
Создает новый цикл событий, запускает переданную сопрограмму coro и в конце закрывает цикл событий. Если в программе используются асинхронные генераторы или пул потоков, то функция завершит их работу тоже.
Её следует использовать в качестве основной точки входа для программ с использованием asyncio, а в идеале asyncio.run() следует вызывать только один раз.

await asyncio.sleep(delay, result=None, *)
# delay - задержка выполнения задачи, result=None - результат, который возвращается вызывающей стороне

await asyncio.shield(aw, *, loop=None)
# aw - объект задачи
shield() защищает объект задачи от отмены методом Task.cancel(), вызывая исключение asyncio.CancelledError, но позволяет защищенной задаче продолжать выполнение.

asyncio.wait_for(aw, timeout, *, loop=None)
# aw - awaitable - объект ожидания, timeout - время, которое нужно ждать, после которого происходит отмена задачи,
Функция wait_for() модуля asyncio ждет, пока awaitable объект aw завершится с таймаутом timeout. Если таймаут равен None, то происходит блокировка до завершения Future.
Если истекает тайм-аут, то функция asyncio.wait_for() отменяет задачу и вызывает ошибку asyncio.TimeoutError.

asyncio.as_completed(aws, *, loop=None, timeout=None)
# aws - множество объектов ожидания, timeout=None - максимальное количество секунд ожидания.
запускает и ждет выполнения переданных в нее задач/awaitable-объектов, и как только появляются результаты у какой-нибудь задачи, в реальном времени, начинает возвращать их в итераторе. Результаты извлекаются, запуском каждого объекта итератора при помощи оператора await.
Вызывает исключение asyncio.TimeoutError, если тайм-аут наступает до того, как все задачи/awaitable-объекты будут выполнены.

done, pending = asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)
# aws - множество объектов ожидания, timeout=None - максимальным количеством секунд ожидания, return_when=ALL_COMPLETED - когда функция должна возвратить результат.
одновременно запускает awaitable-объекты (преимущественно задачи Task) из переданного множества aws и производит блокировку выполнения программы до выполнения условия, указанного в аргументе return_when.
Возвращает кортеж из двух множеств Task/Future в виде (done, pending).

await asyncio.to_thread(func, /, *args, **kwargs)
# func - функция, которая может заблокировать цикл событий, *args - аргументы func, **kwargs - ключевые аргументы func.
асинхронно запускает блокирующую цикл событий функцию func в отдельном потоке.
*args и **kwargs, переданные в функции asyncio.to_thread(), напрямую передаются в запускаемую func.
обычно используется только для функций связанных с вводом/выводом.


await asyncio.run_coroutine_threadsafe(coro, loop)
# coro - сопрограмма, loop - цикл событий.
отправляет сопрограмму coro в заданный цикл событий loop. Функция поточно-ориентирована.
предназначена для вызова сопрограмм в потоке, отличным от того, в котором запущен основной цикл событий. Для этой цели необходимо явное создание отдельного потока.


asyncio.all_tasks()
возвращает множество еще не завершенных задач asyncio.Task, запущенных циклом loop.

asyncio.current_task()
возвращает текущий запущенный экземпляр задачи asyncio.Task или None, если ни одна задача не запущена.



# ===== CLASS TASK ==================================================================
task = asyncio.Task(coro, *, loop=None, name=None)
# coro - сопрограмма Python, name=None - имя задачи.
Класс Task() это объект, который запускает сопрограмму и похож на объект asyncio.Future, т.к. является подклассом этого объекта, наследует от объекта asyncio.Future все его методы, кроме Future.set_result() и Future.set_exception().

asyncio.create_task(coro, *, name=None)
# coro - асинхронная функция coroutine, name=None - имя задачи.
Функция create_task() модуля asyncio оборачивает сопрограмму coro в задачу task и планирует ее выполнение в ближайшее время. Возвращает объект Task. Объект задачи всегда следует запускать с оператором await.
Асинхронные функции не должны содержать внутри себя операции, блокирующие ход выполнения программы! Для запуска из асинхронного кода функций, которые могут блокировать ход выполнения программы используйте субпроцессы или функцию, доступную с Python 3.9 asyncio.to_thread().

await asyncio.gather(*aws, loop=None, return_exceptions=False)
# *aws - последовательность объектов ожидания, return_exceptions=False - обработка исключений.
Функция gather() одновременно запускает объекты awaitable, переданные в функцию как последовательность *aws.

Task.cancel() отменяет запущенную задачу, выдаст исключение asyncio.CancelledError, которое поступит в обернутую сопрограмму. Если, во время отмены, сопрограмма ожидает готовности объекта Future, то объект Future будет отменен.

Task.cancelled() можно использовать для проверки того, была ли задача отменена.
Task.done()
Task.result()
Task.exception()
Task.get_stack(*, limit=None)
Task.get_coro()
Task.get_name()


# ===== QUEUE ==================================================================
asyncio.Queue(maxsize=0, *, loop=None)
Очереди можно использовать для распределения нагрузки между несколькими параллельными задачами.
очереди asyncio не являются потокобезопасными
https://docs-python.ru/standart-library/modul-asyncio-python/ocheredi-queue-modulja-asyncio/


asyncio.PriorityQueue
вариант очереди Queue, которая извлекает записи в порядке приоритета (самый низкий приоритет - первый).
Записи обычно представляют собой кортежи формы (priority_number, data).


asyncio.LifoQueue
вариант очереди Queue, которая сначала извлекает самые последние добавленные записи (last in, first out).

















