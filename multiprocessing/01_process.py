# https://docs-python.ru/standart-library/paket-multiprocessing-python/funktsija-process-modulja-multiprocessing/

# ==============================================================================================
# Методы объекта Process
# Объект Process() запускает вызываемый объект target на исполнение в отдельном процессе/ядре процессора
# Имеет эквиваленты всех методов объекта Thread().
# ==============================================================================================

import multiprocessing

# Конструктор всегда следует вызывать с ключевыми аргументами
proc = multiprocessing.Process(
    group=None,                 # не используется - всегда должен быть None; существует для совместимости с threading.Thread()
    target=None,                # вызываемый методом Process.run() объект (функция)
    name=None,                  # имя процесса
    args=(),                    # кортеж аргументов для target
    kwargs={},                  # словарь аргументов для target
    *,
    daemon=None                 # демонизация процесса. Если daemon=None (по умолчанию), флаг будет = флагу проц. создателя.
    )

"""
Существует 2 способа запустить действие:
- Передать вызываемый объект (функцию) target в конструктор.
- Переопределить метод Process.run() или __init__() в подклассе. Другие методы переопределять нельзя.

Методы Process.start(), Process.join(), Process.is_alive(), Process.terminate() и Process.exitcode должны вызываться только процессом, создавшим этот объект процесса.
"""

Process.run()
# вызывает функцию target с args и kwargs 

Process.start()
# запускает экземпляр Process в отдельном процессе/ядре процессора

Process.join(timeout)
# метод ждет завершения процесса.
# timeout=None (по умолчанию). Выполнение программы будет заблокировано, пока созданные процессы не завершаться.
# Если timeout > 0, то процесс блокируется не более чем на величину секунд timeout.
# Метод возвращает None, если его процесс завершается или если время ожидания метода истекает.

Process.name
# имя процесса - строка для идентификации. Имя может быть любым и даже одинаковым с другими процессами.

Process.is_alive()
# является ли процесс живым. Является живым с момента вызова Process.start() и до завершения порожденного дочернего процесса.

Process.daemon
# флаг демона процесса. Должен быть установлен перед вызовом Process.start()
# Начальное значение наследуется от процесса создателя. Демоническому процессу не разрешается создавать дочерние процессы.
# Когда процесс завершается, он пытается завершить все свои демонические дочерние процессы.

Process.pid
# возвращает идентификатор процесса или None если процесс еще не порожден

Process.exitcode
# код выхода порожденного процесса или None, если процесс еще не завершен.

Process.authkey
# ключ аутентификации процесса. Основному процессу присваивается строка os.urandom(). Объект процесса наследует ключ родительского процесса.

Process.sentinel
# дескриптор объекта завершенного процесса

Process.terminate()
# завершает процесс. Дочерние процессы, при вызове в родителе Process.terminate() станут "осиротевшими". Нельзя использовать вместе с Pipe и Queue.

Process.kill()
# делает то же, что и Process.terminate()

Process.close()
# Закрывает объект роцесса и освобождает все связанные с ним ресурсы.


# ==============================================================================================
# Пример работы с объектом Process
# ==============================================================================================
import multiprocessing

# какая то рабочая функция
def say_hello():
    print('hello')

# создание, запуск и ожидание завершения
p = multiprocessing.Process(target=say_hello)
p.start()
p.join()

# просмотр данных о процессе
print(p.name)                   # Process-1
print(p.is_alive())             # False
print(p.pid)                    # 9306
print(p.exitcode)               # 0
print(p.authkey)                # b'\xd0\xa8\xba(\xc8\x8f\x7fA\xa5%\xb3v3\xd2S0UL\xd1\xb2a\x96\xe5\xc8\xb5\r\xa0\xad\x89\xe9!@'
print(p.sentinel)               # 6

# закрытие объекта процесса с освобождением всех занятых им ресурсов
p.close()

# ==============================================================================================
# Пример работы с несколькими процессами
# ==============================================================================================

import multiprocessing
import os
import time


# текущий процесс
print(multiprocessing.current_process())       # <_MainProcess name='MainProcess' parent=None started>
print(multiprocessing.freeze_support())        # None

# какая то рабочая функция
def say_hello():
    print(p.name, 'says hello')
    print('Parent process: ', multiprocessing.parent_process())     # <_ParentProcess name='MainProcess' parent=None unknown>
    print('Current process: ', multiprocessing.current_process())   # <Process name='Process-1' parent=11919 started>
    time.sleep(5)


# создание и запуск
procs = []
for i in range(2):
    p = multiprocessing.Process(target=say_hello)
    procs.append(p)
    p.start()


# список активных дочерних процессов
print(multiprocessing.active_children())  
# [<Process name='Process-2' pid=12348 parent=12346 started>, <Process name='Process-1' pid=12347 parent=12346 started>]

# ждем окончания выполнения всех процессов
[proc.join() for proc in procs]


# ==============================================================================================
# 3 варианта запуска процесса
# ==============================================================================================
"""
= fork
Доступно только в Unix. По умолчанию в Unix.
Родительский процесс использует os.fork() для разветвления интерпретатора Python.
Дочерний процесс фактически идентичен родительскому процессу.
Все ресурсы родительского процесса наследуются дочерним процессом.

Метод запуска fork следует считать небезопасным, так как он может привести к сбоям подпроцесса.

= spawn
Доступно в Unix и Windows. По умолчанию в Windows и macOS.
Родельский процесс запускает дочерний.
Дочерний унаследует только ресурсы для запуска метода Process.run() объекта multiprocessing.Process.
Этот вариант запуска более медленный, чем другие.

= forkserver
При запуске сначала запускается однопоточный процесс сервера. Использование os.fork() безопасно. Ненужные ресурсы не наследуются.
Для создания нового процесса родительский процесс подключается к серверу и запрашивает его разветвление для нового процесса.

Для установки можно использовать 2 варианта:
"""

# === Вариант 1 через multiprocessing.set_start_method('spawn')

import multiprocessing

def worker(q):                                                 # принимает очередь
    q.put('hello')                                             # ставит элемент 'hello' в очередь

if __name__ == '__main__':
    multiprocessing.set_start_method('spawn')                  # выбор метода запуска процесса. Можно использовать только 1 раз
    q = multiprocessing.Queue()                                # создание очереди
    p = multiprocessing.Process(target=worker, args=(q,))      # создание процесса(функция, очередь)
    p.start()                                                  # запуск
    print(q.get())                                             # удаляет и возвращает элемен из очереди
    p.join()                                                   # ждет когда все процессы завершаться


# === Вариант 2 через объект контекста ctx = multiprocessing.get_context('spawn')
# объект контекста озволяет использовать разные методы запуска в одной программе.

import multiprocessingдерживает асинхронное выполнение задач с тайм-аутами и обратными

def worker(q):
    q.put('hello')                                             # ставит элемент в очередь

if __name__ == '__main__':
    ctx = multiprocessing.get_context('spawn')                 # выбор метода запуска процесса
    q = ctx.Queue()                                            # создание очереди
    p = ctx.Process(target=worker, args=(q,))                  # создание процесса(функция, очередь)
    p.start()                                                  # запуск
    print(q.get())                                             # удаляет и возвращает элемен из очереди
    p.join()                                                   # ждет когда все процессы завершаться



