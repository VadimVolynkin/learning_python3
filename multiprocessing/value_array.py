Для процессов и их потомков в multiprocessing можно создавать общие объекты Value или Array, которые будут содержать общую память.  
Для использования списка list Python или словаря dict в качестве общего ресурса для создаваемых процессов, можно использовать multiprocessing.Manager().

# ==============================================================================================
# multiprocessing.Value()
# общий синхронизированный объект для процессов
# ==============================================================================================

multiprocessing.Value(typecode_or_type, *args, lock=True) 

typecode_or_type
# тип возвращаемого объекта: тип ctypes или односимвольный код типа, используемого модулем array. 

*args
# значение, которое передается конструктору для данного типа.

lock
# lock=True (по умолчанию), создаст новый объект рекурсивной блокировки для синхронизации доступа к значению.
# lock=False - доступ к возвращаемому объекту не будет автоматически защищен блокировкой, и он будет "безопасным для процесса".
# Если lock - это объект Lock или RLock, то он будет использоваться для синхронизации доступа к значению.

# =========================================================================================
import multiprocessing
val = multiprocessing.Value('i', 10)
val.value                                   # 10

val.value = val.value - 1
val.value                                   # 9


# ==============================================================================================
# multiprocessing.Array() 
# общий синхронизированный массив для процессов
# ==============================================================================================

multiprocessing.Array(typecode_or_type, size_or_initializer, *, lock=True)   
# массив types.c_char имеет атрибуты value и raw, которые позволяют использовать его для хранения и извлечения строк

typecode_or_type
# тип возвращаемого объекта: тип ctypes или односимвольный код типа, используемого модулем array. 

size_or_initializer
# размер массива можно только 1 раз, в момент создания экземпляра.

lock
# lock=True (по умолчанию) создает новый объект блокировки для синхронизации доступа к значению. 
# lock=False - доступ к возвращаемому объекту не будет автоматически защищен блокировкой, и он будет "безопасным для процесса".
# Если значение lock - это объект Lock или RLock, то он будет использоваться для синхронизации доступа к значению.

# =========================================================================================
import multiprocessing
arr = multiprocessing.Array('i', range(10))       # создаст объект Array с значениями от 0 до 10

print([i for i in arr if i != 0])                 # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
















