# https://docs-python.ru/standart-library/paket-multiprocessing-python/poluchenie-svedenij-protsessah-modul-multiprocessing/

"""
# ===== Мультипроцессинг =========================================================================================
Мультипроцессинг следует использовать там, где процессы производят вычисления в процессоре(какие то математические операции), им не нужно долго ждать получения данных извне.
Инструкции выполняются параллельно на нескольких процессорах(ядрах).
Каждый процесс имеет свой независимый кусок памяти(heap).
==================================================================================================================
"""

import multiprocessing
import os

# получение информации о ядрах
multiprocessing.cpu_count()              # 4 - количество имеющихся ядер процессора
os.cpu_count()                           # 4 - количество имеющихся ядер процессора
os.sched_getaffinity(0)                  # {0, 1, 2, 3} Количество ядер, которое может использовать текущий процесс


multiprocessing.active_children()        # список всех живых дочерних процессов
multiprocessing.current_process()        # возвращает объект Process текущего процесса
multiprocessing.parent_process()         # возвращает объект Process родительского процесса. None если это родитель

multiprocessing.freeze_support()         # поддержка замороженных процессов

multiprocessing.get_all_start_methods()  # ['fork', 'spawn', 'forkserver'] список поддерживаемых методов запуска
# первый по умолчанию

multiprocessing.get_all_start_methods()   # ['fork', 'spawn', 'forkserver'] список поддерживаемых методов, fork - по дефолту
multiprocessing.get_start_method()        # fork возвращает имя метода запуска
multiprocessing.set_start_method('spawn') # устанавливает метод запуска дочерних процессов
multiprocessing.set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))  # задает путь интерпретатора Python для доч проц. По умолчанию используется sys.executable

multiprocessing.get_context()             # <multiprocessing.context.ForkContext object at 0x7fb0c67a37c0> объект контекста


# ==============================================================================================
# CREATE PROCESS
# ==============================================================================================
proc = multiprocessing.Process(
    group=None,             # не используется модулем
    target=None,            # вызываемый объект (функция)
    name=None,              # имя процесса
    args=(),                # аргументы для target
    kwargs={}, *,           # ключевые аргументы для target
    daemon=None             # флаг для демонизации процесса
    )
# ==============================================================================================
# РЕКОМЕНДАЦИИ
# ==============================================================================================
1. Избегайте общих ресурсов. Лучше использовать очереди или каналы между процессами, чем примитивы синхронизации.
2. Убедитесь,что аргументы методов прокси-объектов являются упакованы модулем pickle.
3. Не используйте прокси-объект из более чем одного потока, если вы не защитите его блокировкой.
4. Хорошей практикой является явное присоединение ко всем процессам, которые запускаются.
5. Лучше наследовать, чем pickle/unpickle. Процесс, которому нужен доступ к общему ресурсу, должен имеьт возможность унаследовать его от процесса-предка.
6. Избегайте завершения процессов с общими ресурсами методом Process.terminate() - это может сломать блокировки, семафоры, каналы и очереди.
7. Всякий раз, когда используется очередь, необходимо убедиться, что все элементы, помещенные в очередь, в конечном итоге будут удалены до присоединения к процессу.
8. Явная передача объекта общего ресурса конструктору дочернего процесса при fork в качестве аргумента.
9. Остерегайтесь замены sys.stdin на файловый объект. Если несколько процессов вызовут file.close() - одни и те же данные будут сброшены в него несколько раз.

# ========================================================================================================================
Процесс - виртуальная среда для выполнения программы(контейнер с данными) или части программы. 
Процессы работают в пространстве индивидуальной памяти. 
Процессорное время распределяет ядро.
Процессы могут обмениваться сообщениями друг с другом(буфер двоичных байтов) через каналы или сетевые соединения, либо через отображаемою совместную память.
Для избежания гонки за общими ресурсами используются блокировки.

Потоки (нити)- составляющие процесса. Каждый процесс имеет минимум один поток(основной), может иметь дочерние - это уже многопоточность. 
Нити - это процессы, которые работают в пространстве общей памяти одного процесса.
Нити бывают ядерные(kernel spase) - их диспедчеризацией занимается ядро проца и неядерными (user space). В windows неядерные нити называются fiber.

===== Существует 2 канала связи между процессами:
= 1. Очереди Queues, в собственной реализации
Очереди безопасны для потоков в разных ядрах процессора.

= 2. Каналы Pipes multiprocessing.Pipe()
Возвращает пару объектов, соединенных каналом, которые по умолчанию является duplex двусторонним.
Каждый объект имеет методы Pipe.send() - посылает данные в канал и Pipe.recv() - читает данные из канала.
Данные в канале могут быть повреждены, если два процесса или потока попытаются читать или записывать в один и тот же конец канала одновременно.

# ==============================================================================================

===== Примитивы синхронизации на разных ядрах
Блокировка Lock - только один процесс печатает на стандартный вывод за раз.
Без использования блокировки вывод различных процессов может все перемешать.


===== Несколько способов использования обзего состояния между процессами

=== Общая память Shared memory:
= multiprocessing.Value
= multiprocessing.Array

=== Серверный процесс Server process
multiprocessing.Manager() вернет объект SyncManager для управления серверным процессом, который содержит объекты Python и позволяет другим процессам манипулировать ими с помощью прокси-объектов.
Менеджеры серверных процессов более гибкие, чем использование объектов общей памяти, т. к. могут быть созданы для поддержки произвольных типов объектов, но они медленнее. 
