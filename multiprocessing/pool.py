# ==============================================================================================
# POOL
# Создает объект, управляющий пулом рабочих процессов, в который могут быть отправлены задания.
# Пул рабочих процессов поддерживает асинхронное выполнение задач с тайм-аутами и обратными вызовами и имеет параллельную реализацию.
# ==============================================================================================

from multiprocessing import Pool

# создание объекта пула
pool = Pool(
    processes,         # количество используемых рабочих процессов. Если явно не указан, то os.cpu_count().
    initializer,       # вызываемый объект (функция)
    initargs,          # аргументы для initializer
    maxtasksperchild,  # макс. количество выполненных задач рабочего процесса до выхода и замены на новый процесс. По умолчанию None - живет как пул
    context            # контекст для запуска рабочих процессов
    )

# ==================================================================================

Pool.apply(func, args, kwds)
# вызывает функцию с аргументами и блокирует выполнение программы до готовности результата
# аргумент метода func выполняется только в одном рабочем процессе пула

Pool.apply_async(func, args, kwds, callback, error_callback)
# асинхронный вариант метода Pool.apply()

Pool.map(func, iterable, chunksize)
# многопроцессорный эквивалент встроенной функции map(), (функиция, итерируемый объект с еднственным аргументом, размер частей)
# разбивает итерируемый объект на несколько частей, которые отправляет в пул процессов как отдельные задачи
# блокирует выполнение программы до получения результатов работы всеми запущенными процессами.

Pool.map_async(func, iterable, chunksize, callback, error_callback)
# асинхронный вариант метода Pool.map()

Pool.imap(func, iterable, chunksize)
# более ленивая версия метода Pool.map()

Pool.imap_unordered(func, iterable, chunksize)
# то же самое, что и Pool.imap(), только результаты идут по готовности

Pool.starmap(func, iterable, chunksize)
# аналогичен методу Pool.map(), но аргумент может быть итерируемым iterable=[(1, 2), (3, 4)]

Pool.starmap_async(func, iterable, chunksize, callback, error_callback)
# комбинация методов Pool.starmap() и Pool.map_async()

Pool.close()
# предотвращает отправку задач в пул. Как только все задачи будут выполнены, рабочие процессы завершатся.

Pool.terminate()
# останавливает рабочие процессы. Метод останавливает рабочие процессы немедленно, не давая завершить невыполненную работу.

Pool.join()
# ждет, пока рабочие процессы закончатся. Перед использованием Pool.join() необходимо вызвать Pool.close() или Pool.terminate().


# === Объект AsyncResult представляет собой результат, возвращаемый методами Pool.apply_async() и Pool.map_async().
AsyncResult.get(timeout)
# возвращает результат, как только он придет. Если timeout не None и результат не приходит, то исключение TimeoutError

AsyncResult.wait(timeout)
# ждет, пока будет доступен результат или пока не пройдет время timeout

AsyncResult.ready()
# проверяет, завершился ли вызов

AsyncResult.successful()
# проверяет, был ли завершен вызов без исключения. Поднимет исключение ValueError, если результат не готов.



# ==============================================================================================
# КАК ЗАПУСТИТЬ POOL
# ==============================================================================================
"""
=== 3 способа запуска процесса:

= fork
Доступно только в Unix. По умолчанию в Unix.
Родительский процесс использует os.fork() для разветвления интерпретатора Python.
Дочерний процесс фактически идентичен родительскому процессу.
Все ресурсы родительского процесса наследуются дочерним процессом.

Метод запуска fork следует считать небезопасным, так как он может привести к сбоям подпроцесса.

= spawn
Доступно в Unix и Windows. По умолчанию в Windows и macOS.
Родельский процесс запускает дочерний.
Дочерний унаследует только ресурсы для запуска метода Process.run() объекта multiprocessing.Process.
Этот вариант запуска более медленный, чем другие.

= forkserver
При запуске сначала запускается однопоточный процесс сервера. Использование os.fork() безопасно. Ненужные ресурсы не наследуются.
Для создания нового процесса родительский процесс подключается к серверу и запрашивает его разветвление для нового процесса.

Для установки можно использовать 2 варианта:
"""
# === Вариант 1 через multiprocessing.set_start_method('spawn')

import multiprocessing

def worker(q):                                                 # принимает очередь
    q.put('hello')                                             # ставит элемент 'hello' в очередь

if __name__ == '__main__':
    multiprocessing.set_start_method('spawn')                  # выбор метода запуска процесса. Можно использовать только 1 раз
    q = multiprocessing.Queue()                                # создание очереди
    p = multiprocessing.Process(target=worker, args=(q,))      # создание процесса(функция, очередь)
    p.start()                                                  # запуск
    print(q.get())                                             # удаляет и возвращает элемен из очереди
    p.join()                                                   # ждет когда все процессы завершаться


# === Вариант 2 через объект контекста ctx = multiprocessing.get_context('spawn')
# объект контекста озволяет использовать разные методы запуска в одной программе.

import multiprocessing

def worker(q):
    q.put('hello')                                             # ставит элемент в очередь

if __name__ == '__main__':
    ctx = multiprocessing.get_context('spawn')                 # выбор метода запуска процесса
    q = ctx.Queue()                                            # создание очереди
    p = ctx.Process(target=worker, args=(q,))                  # создание процесса(функция, очередь)
    p.start()                                                  # запуск
    print(q.get())                                             # удаляет и возвращает элемен из очереди
    p.join()                                                   # ждет когда все процессы завершаться









