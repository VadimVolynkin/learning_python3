# ===== Способы работы с модулем ================================================

# 1. модуль можно импортировать
import some_module

# 2. модуль можно запустить как самостоятельную программу
python some_module.py

# === Проверить, был ли модуль запущен как программа или импорт модуля
if __name__ == '__main__':
    # Да- инструкции
    print('hello from main modules')
else:
    # Нет, файл был импортирован как модуль - инструкции

__name__     имя модуля, текущий модуль вернет __main__, импортированный module.__name__  вернет имя module

# ===== Полезные функции ========================================================
import module                    # попытается загрузить модуль из стандартной библиотеки
some_module.__dict__             # модуль – это словарь, который хранит содержимое пространства имен модуля
sys.modules                      # все модули загруженные к этому моменту
sys.path                         # список каталогов поиска модулей
dir()                            # список содержимого текущего пакеа или пакеа из аргумента

# ===== Import Module ===========================================================
При первом импорте инструкцией import модуль автоматически компилируется в байт-код и сохраняется на диске в файле с расширением .pyc или .pyo. При последующих импортах модуля интерпретатор грузит скомпилированный байт-код, если он не изменился - иначе создаст заново .pyc. Файлы .pyc могут зависеть от версии интерпретатора.

Файлы .pyo создаются, если интерпретатор запускается с ключом -O. В этом случае из байт-кода удаляются номера строк,
инструкции assert и прочая отладочная информация.

Файлы .pyo создаются, если вместо -O использовать ключ -OO, из файла также будут удалены строки документирования.

# === при первой загрузке import some_module
1. Создает новое пространство имен для всех объектов файла. Оно будет доступно функциям и методам,
   объявленным в этом модуле, использующим инструкцию global.
2. Выполняет программный код внутри пространства имен.
3. Создает в вызывающей программе имя some_module, ссылающееся на пространство имен модуля.

# === from some_module import some_func
from идентична инструкции import, но не создает пространство имен модуля, а импортирует в текущее
some_func - ссылка на импортируемый объект в текущем пространстве имен
from some_module import *  импортирует из модуля все или только __all__ = [ 'var_name', 'func', 'Class' ]

# можно импортировать
Файлы с расширением .py
Расширения на C или C++, скомпилированые в виде разделяемых библиотек или DLL
Пакеты, содержащие коллекции модулей
Встроенные модули, написанные на языке C и скомпонованные с интерпретатором Python

# === Путь поиска модулей
sys.path                         # список каталогов поиска модулей
Из архивов .zip можно импортировать только файлы с расширениями .py, .pyw, .pyc и .pyo.
.egg – это пакеты, созданные с помощью библиотеки setuptools

1. Каталог foo, объявленный как пакет.
2. foo.pyd, foo.so, foomodule.so или foomodule.dll (скомпилированные расширения).
3. foo.pyo (только если при компиляции был использован ключ -O или -OO).
4. foo.pyc.
5. foo.py (в Windows интерпретатор также проверяет наличие файлов с расширением .pyw).

Если интерпретатор не обнаружит ни один из этих файлов в каталогах в списке sys.path, он проверит,
не соответствует ли это имя встроенному модулю. Если такого встроенного модуля не существует,
будет возбуждено исключение ImportError.


# ===== Список с переменными текущего модуля ===========================================================
print(dir())
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']

__annotations__               # вернет какой то словарь
__cached__                    # вернет путь к файлу кеша pyc, если он есть
__file__                      # вернет путь к файлу или пакету
__name__                      # текущий модуль вернет __main__, импортированный module.__name__  вернет имя module
package.__loader__.__dict__   # вернет словарь с name, path
package.module.__package__    # вернет имя package
package.module.__spec__       # вернет именованный кортеж name, loader, origin

# ===== Импорты пакетов ================================================================================
__init__.py                                  # файл в каждом пакете, при импорте выполняет все инструкции
__all__ = ['module1', 'module2']             # нужен для импорта вида from package import *
from . import module1, module2               # нужен для импорта вида import package
__path__                                     # список каталогов для поиска модулей пакета - аналог списка sys.path для пакета





# ===== модуль можно перезагрузить ================================================================================
from importlib import reload
reload(mymath)






