# https://pythonworld.ru/moduli/modul-collections


# ================================================================================================================
# КЛАСС ChainMap()
# ================================================================================================================
# объединяет несколько словарей, чтобы работать с ними как с единым объектом
# объединяет словари и ищет ключи быстрее dict
# может имитировать сложенные области и помогает создавать шаблоны

import collections

d = collections.ChainMap(*maps)
# *maps - один или несколько словарей
# если maps не указаны, то будет создан пустой словарь
# при добавлении словарей одинаковые ключи не перезаписываются новыми значениями, вместо этого словари добавляются в список атрибута ChainMap.maps
# класс поддерживает все основные операции dict
# операции добавления, обновления и удаления ключей и значений могут быть произведены только со словарем, который был добавлен первым
# поиск по ключу происходит во всех словарях слева направо, вернет только первый найденный результат
# Python 3.9+ добавлена ​​поддержка операторов слияния словарей (|) и обновления словарей (|=)
# класс хранит только ссылки на словари - изменения в исходном словаре изменят данные в ChainMap и наоборот
# итерация словаря происходит в обратном порядке

from collections import ChainMap

first = {'two': 22, 'three': 3}
last = {'one': 1, 'two': 2}

d = ChainMap(first, last)
# ChainMap({'two': 22, 'three': 3}, {'one': 1, 'two': 2})


# ===== d.maps - список всех добавленных словарей

print(d.maps)
# [{'two': 22, 'three': 3}, {'one': 1, 'two': 2}]


# ===== операции добавления, изменения и удаления ключей доступны только в первом добавленном словаре

d['four'] = 4                  # добавляем в словарь элемент
# ChainMap({'two': 22, 'three': 3, 'four': 4}, {'one': 1, 'two': 2})

d.popitem()                    # ('four', 4)
# ChainMap({'two': 22, 'three': 3}, {'one': 1, 'two': 2})

d['one'] = 11                  # пробуем изменить первый элемент второго словаря - меняется первый словарь 
# ChainMap({'two': 22, 'three': 3, 'one': 11}, {'one': 1, 'two': 2})


# ===== изменяем исходные словари - словарь ChainMap тоже меняется 
del first['two']               # удаление элемента из словаря1
last['four'] = 4               # добнавление элемента в словарь2
# ChainMap({'three': 3, 'one': 11}, {'one': 1, 'two': 2, 'four': 4})


# ===== поиск значения по ключу слева-направо возвращает первое найденное значение
d['one']                       # 11    такой ключ есть в обоих словарях - это первый найденный результат
d['two']                       # 2     ключ есть только в словаре2 - результат взят из него


# ===== итерация происходит в обратном порядке

# текущее состояние словаря d
# ({'three': 3}, {'one': 1, 'two': 2, 'four': 4})

# итерируем словарь путем получения списка его ключей
print(list(d))                 
# ['one', 'two', 'four', 'three']
# список начинается с последнего словаря слева направо, потом словарь до него слева направо и тд


# ================================================================================================================
# АТРИБУТЫ ChainMap()
# ================================================================================================================

# ===== ChainMap.maps - список всех добавленных словарей ===================
# должен всегда содержать минимум 1 словарь
# поддерживает все основные операции с list
# через атрибут maps можно изменять ВСЕ словари

print(d.maps)               # текущее состояние          [{'three': 3}, {'one': 1, 'two': 2, 'four': 4}]
del d.maps[1]['four']       # удаление ключа из словаря2 [{'three': 3}, {'one': 1, 'two': 2}]
d.maps[1]['four'] = 4       # создание ключа в словаре2  [{'three': 3}, {'one': 1, 'two': 2, 'four': 4}]

# ===== ChainMap.new_child(m=None) =========================================
# возвращает новый экземпляр ChainMap(), содержащий новый словарь m, за которым следуют все словари в текущем экземпляре
# если указан словарь m, то он вставляется первым в списке существующих словарей текущего экземпляра
# если m не указан, то используется пустой dict, так что вызов d.new_child() эквивалентен вызову ChainMap({}, *d.maps). 
# метод используется для создания подконтекстов, которые могут быть обновлены без изменения значений в любом из родительских словарей.

d_child = d.new_child()
# ChainMap({}, {'three': 3}, {'one': 1, 'two': 2, 'four': 4})

d_child = d.new_child({'one': 1, 'a': 1})
# ChainMap({'one': 1, 'a': 1}, {'three': 3}, {'one': 1, 'two': 2, 'four': 4})


# ===== ChainMap.parents ===================================================
# Атрибут возвращает новый экземпляр ChainMap(), содержащий все словари в текущем экземпляре, кроме первого. Это полезно для пропуска первого словаря при поиске ключей.

d_parents = d_child.parents          # вызов d.parents - эквивалент ChainMap(*d.maps[1:])
# ChainMap({'three': 3}, {'one': 1, 'two': 2, 'four': 4})


# ================================================================================================================
# ПРИМЕР ИСПОЛЬЗОВАНИЯ ChainMap() ДЛЯ ИМИТАЦИИ ВЛОЖЕННЫХ КОНТЕКСТОВ ПИТОНА
# ================================================================================================================
from collections import ChainMap

c = ChainMap({'root1': 'root_value1'})              # создаем корневой контекст
# ChainMap({'root1': 'root_value1'})

e = c.new_child({'e_child1': 'e_child_value1'})     # создаем дочерний контекст от с
# ChainMap({'e_child1': 'e_child_value1'}, {'root1': 'root_value1'})

e.maps[0]             # первый словарь дочернего контекста - его собственный - это как locals()
# {'e_child1': 'e_child_value1'}

e.maps[-1]            # последний словарь дочернего контекста - словарь родителя - это как globals()
# {'root1': 'root_value1'}

e.parents             # все словари кроме собственного - это как Enclosing цепочка контекста nonlocals
# ChainMap({'root1': 'root_value1'})

e['x'] = 1            # добавляем ключ в дочерний контекст
e['x']                # получаем значение по ключу из цепочки контекстов(ищет в locals, потом в globals)
# ChainMap({'e_child1': 'e_child_value1', 'x': 1}, {'root1': 'root_value1'})

list(e)               # список всех ключей дочернего контекста
# ['root1', 'e_child1', 'x']




















