# ================================================================================================================
# Класс Counter()
# ================================================================================================================
import collections

cnt = collections.Counter([iterable-or-mapping])
# iterable-or-mapping - итерируемая последовательность или словарь
# Counter() - подкласс dict для бытрого и удобного подсчета хеш-объектов (неизменяемых: строк, чисел, кортежей ...)
# Элементы хранятся в виде словарных ключей, а их счетчики хранятся в виде значений словаря.
# Счетчик может быть любым целочисленным значением, включая ноль или отрицательное число.
# Значением может быть что угодно, н обязательно число.
# Элементы считываются из итерируемой последовательности, инициализируются из другого словаря или счетчика Counter().
# Счетчик имеет интерфейс словаря, но при отсутствии ключа при запросе возвращает 0, а не KeyError.
# Counter() унаследовал возможность запоминания порядка вставки.

# ================================================================================================================
# СОЗДАНИЕ ЭКЗЕМПЛЯРА С РАЗНЫМИ ТИПАМИ ДАННЫХ
# ================================================================================================================
from collections import Counter

# новый пустой счетчик
cnt = Counter()
# Counter()

# новый счетчик из последовательности
cnt = Counter(('one', 'two', 'three', 'one'))
# Counter({'one': 2, 'two': 1, 'three': 1})

# новый счетчик из словаря
cnt = Counter({'red': 4, 'blue': 2})
# Counter({'red': 4, 'blue': 2})

# новый счетчик из ключевых слов 'args'
cnt = Counter(cats=4, dogs=8)
# Counter({'dogs': 8, 'cats': 4})


# ================================================================================================================
# АТРИБУТЫ И МЕТОДЫ Counter()
# ================================================================================================================
# доступны почти все методы dict
# метод Counter.fromkeys() не реализован


# ===== Counter.elements() ===============================================================
# возвращает итератор по элементам, в котором каждый элемент повторяется столько раз, во сколько установлено его значение
# элементы возвращаются в порядке их появления
# если количество элементов меньше 1, то метод Counter.elements() проигнорирует его

cnt = Counter(a=4, b=2, c=0, d=-2)
it = cnt.elements()                      # итератор
print(list(it))                          
# ['a', 'a', 'a', 'a', 'b', 'b']


# ===== Counter.most_common(n) ===========================================================
# возвращает отсортированный список из n наиболее распространенных элементов по убыванию
# если n опущено или None - вернет все элементы
# элементы с равным количеством упорядочены в порядке, в котором они встречаются первыми

Counter('abracadabra').most_common(3)
# [('a', 5), ('b', 2), ('r', 2)]


# ===== Counter.subtract([iterable-or-mapping]) ==========================================
# вычитает из значений элементов текущего счетчика значения другого счетчика

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.subtract(d)
# Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})


# ===== Counter.update([iterable-or-mapping]) ============================================
# складывает значения элементов текущего счетчика с значениями другого счетчика

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.update(d)
# Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2})



# ================================================================================================================
# ПРИМЕРЫ РАБОТЫ С Counter()
# ================================================================================================================
from collections import Counter

# создать счетчик из списка кортежей (elem, cnt)
cnt = Counter(dict(list_of_pairs))

# преобразовать в список кортежей (elem, cnt)
cnt.items()

# сумма всех значений в счетчике
sum(cnt.values())

# очистить счетчик
cnt.clear()

# список уникальных элементов
list(cnt)

# преобразовать в множество
set(cnt)

# преобразовать в обычный словарь              
dict(cnt)

# N наименее распространенных элементов
cnt.most_common()[:-n-1:-1]

# Удалить элементы с нулевыми отрицательными значениями
+cnt


c = Counter(a=3, b=1)
d = Counter(a=1, b=2)

# Сложить два счетчика - складываются значения:  c[x] + d[x]
print(c + d)
# Counter({'a': 4, 'b': 3})

# Вычитание счетчиков, сохраняются только положительные значения элементов
print(c - d)                      
# Counter({'a': 2})

# Пересечение счетчиков вернет минимумы:  min(c[x], d[x]) 
print(c & d)
# Counter({'a': 1, 'b': 1})

# Объединение счетчиков вернет максимумы:  max(c[x], d[x])
print(c | d)
# Counter({'a': 3, 'b': 2})



# ================================================================================================================
# ПОДСЧЕТ ОДИНАКОВЫХ СЛОВ В ФАЙЛЕ
# ================================================================================================================

from collections import Counter
from re import findall

with open('some.txt') as fp:
    # ищет только слова без знаков с переводом в нижний регистр
    # findall(что искать, где искать)
    words = findall(r'\w+', fp.read().lower())

cnt = Counter(words).most_common(10)
print(cnt)







