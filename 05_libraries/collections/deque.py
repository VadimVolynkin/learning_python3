# ================================================================================================================
# Двусторонняя очередь в Python deque()
# ================================================================================================================
# позволяет организовать стек и очередь с примерно одинаковой производительностью O(1) в любом направлении

import collections

dq = collections.deque(iterable, maxlen=None)
# iterable - итерируемая последовательность. При создании объекта класс использует dq.append() для добавления элементов.
# maxlen - int, максимальное кол-во хранимых записей, если None - может увеличиваться до произвольной длины.
# если при добавлении новых элементов количество элементов в очереди > maxlen, то удаляются элементы с другого конца.

# ================================================================================================================
# МЕТОДЫ deque()
# ================================================================================================================

Deque.append(x)               # добавляет в конец
Deque.appendleft(x)           # добавляет в начало контейнера
Deque.copy()                  # создает неглубокую копию
Deque.clear()                 # очищает контейнер
Deque.count(x)                # считает количество вхождений x
Deque.extend(iterable)        # добавляет в конец несколько элементов
Deque.extendleft(iterable)    # добавляет в начало несколько элементов, при этом порядок их следования меняется
Deque.index(x, start, stop)   # вернет индекс первого совпадения х. ValueError, если x не найден.
Deque.insert(i, x)            # вставляет x в позицию i. Если будет превышен maxlen, то IndexError.
Deque.pop()                   # удалит и возвратит элемент с конца. Если нет элементов, то IndexError. 
Deque.popleft()               # удалит и возвратит элемент с начала. Если нет элементов, то IndexError. 
Deque.remove(value)           # удалит первое вхождение. Если value не найдено, то IndexError.
Deque.reverse()               # делает рейверс элементов, ничего не возвращает.
Deque.rotate(n=1)             # прокручивает контейнер на n шагов вправо. Если n < 0, то влево.
Deque.maxlen                  # возвращает maxlen 

# ================================================================================================================
# ПРИМЕР1: аналог команды bash tail в Unix
# ================================================================================================================
from collections import deque

def tail(filename, n=10):
    "Вернуть последние 'n' строк файла"
    with open(filename) as f:
        return deque(f, n)


# ================================================================================================================
# ПРИМЕР2: скользящая средняя
# ================================================================================================================
from collections import deque
import itertools

# создадим генератор
def moving_average(iterable, n=3):
    "moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0"
    it = iter(iterable)                    # создаем из последовательности итератор 
    d = deque(itertools.islice(it, n-1))   # deque([40, 30])    создаем очередь, кладем в нее срез
    d.appendleft(0)                        # deque([0, 40, 30]) добавляем в начало очереди 0
    s = sum(d)                             # 70 получаем сумму всех элементов                      
    for elem in it:                        # работаем с оставшимися элементами в итераторе 
        s += elem - d.popleft()            # к сумме прибавляем (текущий элемент - первый из очереди(его удаляем))
        d.append(elem)                     # добавляем элемент в конец очереди
        yield s / n                        # вернем среднее(сумма/количество элем)



iterable = [40, 30, 50, 46, 39, 44]

r = moving_average(iterable, n=3)          # генератор
print(list(r))                             # [40.0, 42.0, 45.0, 43.0]


# ================================================================================================================
# ПРИМЕР3: циклический планировщик с очередями задач из итераторов в очереди deque()
# ================================================================================================================
# Значения выводятся из активного итератора в нулевой позиции.
# Если активный итератор исчерпан, его можно удалить с помощью dg.popleft(). В противном случае его можно циклически вернуть в конец при помощи метода dq.rotate()

from collections import deque


# создаем генератор
def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --> A D E B F C"
    iterators = deque(map(iter, iterables))           # создаем очередь из итераторов
    print(iterators)

    while iterators:                                  # пока в очереди есть итераторы 
        try:
            while True:
                yield next(iterators[0])              # берем элемент первого итератора
                iterators.rotate(-1)                  # делаем сдвиг итераторов влево на 1
        except StopIteration:
            # удаление отработавшего итератора
            iterators.popleft()


iterables = ('ABC', 'D', 'EF')
r = roundrobin(*iterables)
print(list(r))                                        # ['A', 'D', 'E', 'B', 'F', 'C']
