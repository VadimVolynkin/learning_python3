# ================================================================================================================
# ДЛЯ ЧЕГО НУЖНЫ МЕНЕДЖЕРЫ КОНТЕКСТА
# ================================================================================================================
# Организуют выполнение инструкций до работы с объектом и после окончания работы с ним(по сути обертка):
# - сохранение и восстановление различных типов глобального состояния
# - блокировка и разблокировка ресурсов
# - закрытие открытых файлов, соединений

with open('foo.txt', 'rw') as f:           # f вернет результат__enter__() - ссылку на открытый файловый поток.
    for line in f:
        print(line)                        # после завершения работы будет вызван метод __exit__(), который делает f.close()
        

# ================================================================================================================
# Как работает менеджер контекста with
# ================================================================================================================
with EXPRESSION as TARGET:
    SUITE

# 1. Выражение контекста оценивается для получения менеджера контекста.
# 2. Менеджер контекста загружает методы __enter__() и __exit__().
# 3. Менеджер контекста вызывает метод __enter__().
# 4. Если TARGET была включена в оператор with, то ей присваивается возвращаемое значение из метода __enter__().
# Обратите внимание, что оператор with гарантирует, что если метод __enter__() возвращается без ошибки, то всегда будет вызываться метод __exit__(). Таким образом, если ошибка возникает во время присваивания значения через оператор as, то она будет обрабатываться так же, как и ошибка, возникающая внутри with.
# 5. Последовательность команд выполнена.
# 6. Вызван метод __exit__(). Если исключение вызвало выход из последовательности команд, то его тип exc_type, значение exc_val и информация о трассировке exc_tb передаются в качестве аргументов __exit__(). В противном случае предоставляется три аргумента None.


manager = (EXPRESSION)                        # кладем выражение в переменную
enter = type(manager).__enter__               # определяем класс выражения и берем его метод __enter__
exit = type(manager).__exit__                 # определяем класс выражения и берем его метод __exit__
value = enter(manager)                        # функция вызывает метод  __enter__
hit_except = False                            # Переменная исключений - сейчас False 

try:
    TARGET = value                            # присваиваем переменной результат вызова __enter__ с менеджером
    SUITE                                     # здесь будет какая то наша логика 
except:
    hit_except = True                         # если что то упало, то переменная True
    if not exit(manager, *sys.exc_info()):    # вычисляем(тип исключения, его значение, трассировку)
        raise
finally:
    if not hit_except:                        
        exit(manager, None, None, None)       # если ошибок нет, то вернем 3 раза ничего


# вложенные with можно записать так
with A() as a, B() as b:
    SUITE

# или так
with A() as a:
    with B() as b:
        SUITE

# ================================================================================================================
# КАК СОЗДАТЬ
# ================================================================================================================
# Требует реализации 2 методов:

# === 1. __enter__()                    
# Выполняется до тела инструкции
# Вводит контекст среды выполнения и возвращает либо себя, либо другой объект, связанный с контекстом среды выполнения.
# Возвращаемое значение привязывается к as some_var


# === 2. __exit__(exc_type, exc_val, exc_tb)  
# Вызывается по завершению работы (при успехе и при исключении).
# Выход из контекста среды выполнения.
# Если не возникло исключений, вернет (None, None, None).
# Возвращает True или False, чтобы показать, было обработано исключение или нет.


class Resource:
    """Допустим объект этого класса требует вызова
    метода post_work по окончанию работы с ним
    """
    def __init__(self, name):
        print('Resource: create {}'.format(name))
        self.__name = name

    def get_name(self):
        return self.__name

    def post_work(self):
        print('Resource: close')

class ResourceForWith:
    """"Этот контекстный менеджер будет работать с with"""
    # создание внутреннего свойства = объекту с которым будем работать
    def __init__(self, name):
        self.__resource = Resource(name)

    # инструкции до начала работы с объектом - просто вернет объект
    def __enter__(self):                                
        return self.__resource

    # инструкции по окончанию работы с объектом - выполнит метод
    def __exit__(self, type, value, traceback):
        self.__resource.post_work()

# запуск
# будет создан объект с именем Worker
# будет вызван метод post_work по окончанию работы с ним
with ResourceForWith('Worker') as r:
    print(r.get_name())


# ================================================================================================================
# КАК СОЗДАТЬ ЕЩЕ ПРОЩЕ
# ================================================================================================================      
# Модуль contextlib упрощает реализацию собственных менеджеров контекста за счет обертывания функций-генераторов.
# все, что написано до оператора yield вызывается в рамках функции __enter__
# все что после – в рамках __exit__.

from contextlib import contextmanager

@contextmanager
def processor():
    print('--> start processing')       
    yield
    print('<-- stop processing')



with processor():
    print(':: processing')



# ===== ПРИМЕР с БЛОКИРОВКОЙ ===========================================================

# блокировка, полученная в начале блока, освобождается, когда блок закончен
@contextmanager
def locked(lock):
    lock.acquire()
    try:
        yield
    finally:
        lock.release()

with locked(myLock):
    # Здесь код выполняется с удержанным myLock. 
    # lock.release() гарантированно будет выполнен, когда блок
    # будет завершен (даже по необработанному исключению).


# ===== ПРИМЕР с ФАЙЛОМ ===========================================================

# открытие и закрытие файла при завершении блока
@contextmanager
def opened(filename, mode="r"):
    f = open(filename, mode)
    try:
        yield f
    finally:
        f.close()


with opened("/etc/passwd") as f:
    for line in f:
        print line.rstrip()


# ===== ПРИМЕР с ТРАНЗАКЦИЯМИ В БАЗЕ ===========================================================

# зафиксирует или откатит транзакции
@contextmanager
def transaction(db):
    db.begin()
    try:
        yield None
    except:
        db.rollback()
        raise
    else:
        db.commit()


