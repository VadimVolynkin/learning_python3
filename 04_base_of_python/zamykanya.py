# ================================================================================================================
# ЗАМЫКАНИЯ(CLOSURES)
# ================================================================================================================ 
# Внутренние функции, которые пользуются переменными из внешней функции тк имеют ссылку на них.
# Такие функции позволяют сохранить переменные внешней функции после окончания ее работы. 
# Переменные в замыканиях получают значение из внешней функции только во время вызова внутренней функции(эффект позднего связывания).


# ===== КАК СОЗДАТЬ ЗАМЫКАНИЕ
# 1. Создать вложенную функцию
# 2. Во вложенной функции должна быть переменная, опреденная во внешней функции.
# 3. Внешняя функция должна возвращать ссылку на вложенную функцию.


# ===== ДЛЯ ЧЕГО НУЖНЫ ЗАМЫКАНИЯ
# могут выступать в роли фабрик для других функций, осуществляют преднастройку их работы 
# позволяют избежать использования глобальных переменных типа global
# обеспечивают некоторую форму сокрытия данных


# ================================================================================================================
# ПРИМЕРЫ
# ================================================================================================================ 

# ===== УМНОЖЕНИЕ
# mul служит фабрикой для создания и настройки функции helper
# a является локальной для mul() и имеет область enclosing(охватывающая область) в helper().
# a не уничтожается, т.к. во внутренней функции есть ссылка на переменную во внешней функции - это замыкание
def mul(a):
    def helper(b):         # внутренней функции доступны все переменные из внешней
        return a * b       # эта ссылка на a не даст ей быть уничтоженой после прохода блока внешней функции
    return helper          # ссылка на объект внутренней функции

print(mul.__closure__)     # None  является ли функция замыканием. Это еще не замыкание

# Первый вызов функции выполнит ее и вернет ссылку на внутреннюю.
# Переменная а при этом не уничтожается, потому, что на нее есть ссылка во внутренней функции.
res5 = mul(5)              # передача аргумента1 в a
print(res5)                # <function mul.<locals>.helper at 0x7f898a100940> ссылка на функцию helper
print(res5.__closure__)    # (<cell at 0x7f54aa11f310: int object at 0x55880dfd1780>,) функция замыкания(с контекстом)
print(res5.__closure__[0].cell_contents)    # 5 - переменная переданная в объект замыкания 

# Второй вызов запустит внутреннюю функцию helper
res52 = res5(2)            # запуск + передача аргумента2 в b
print(res52)               # 10


# ===== ОЧИСТКА СТРОК ОТ ЛИШНИХ СИМВОЛОВ
def strip_chars(chars):                              # принимает строку с символами
    """
    Функция очищает строку от лишних символов.
    """
    def strings_strip(string):                       # принимает строку для очистки
        if not isinstance(string, str):              # проверка на строку
            raise ValueError('Need to be string')
        return string.strip(chars)                   # удаляет символы
    return strings_strip                             # возвращает ссылку на strings_strip


s1 = strip_chars('/?:;!,.* ')                        # s1 = ссылка на strings_strip + передача chars
print(s1(" . Hello World / !"))                      # вызов strings_strip с передачей string
print(s1('. / * Another string .,??'))               # еще один вызов с другой строкой


# ===== СЧЕТЧИК ВЫЗОВА
def counter():
    count = 0
    def inner():
        nonlocal count       # связвает с внешней count
        count += 1
        return count
    return inner

q = counter() # создает экземпляр замыкания
print(q())    # 1
print(q())    # 2


# ===== ОБЛЕГЧЕННЫЕ ЗАМЫКАНИЯ
# 
def func(i):
    func.a += i
    return func.a

func.a = 1           # устанавливает в функцию атрибут a = 1
func(5)              # 6    вызов с передачей аргумента в i Теперь a = 6.
func(5)              # 11   повторный вызов с передачей аргумента в i