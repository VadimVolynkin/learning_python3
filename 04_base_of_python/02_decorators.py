# https://python-scripts.com/decorators-one
# https://proproprogs.ru/python_base/dekoratory-funkciy-i-zamykaniya
# https://python-scripts.com/decorator-arguments

# TODO Функция декорирует класс
# TODO Класс декорирует класс

"""
Декоратор в Python – это функция, которая в качестве аргумента принимает 1 аргумент - другую функцию и расширяет ее функционал без изменения самой функции. Это позволяет не захламлять бизнеслогику расширяющим кодом.
Декораторы часто используются для определения времени выполнения, оптимизаций, кеширования, логирования, как адаптер, проверка результата, подмена результата, проверка входных данных(аутентификация и тп).

Декоратор внутри содержит функцию-обертку, которая принимает аргументы функции.
Декортатор возвращает ссылку на обертку.
Вызов функции происходит внутри обертки - так мы может выполнять какой либо расширяющий функциональность код до и после вызываемой функции.

К одной функции можно применять много декораторов.
Нельзя раздекорировать функцию(точнее это плохая практика).
Любые вызываемые объекты могут быть декоратором. Нужно прописать метод __call__() в их классе.
Декоратор может принимать аргументы, если завернуть его вызов в обычную функцию.
Декораторы не обязаны возвращать переданную в них функцию - они могут вернуть что угодно, например другую функцию.

Типы декораторов:
- Функция декорирует функцию
- Функция декорирует класс
- Класс декорирует функцию
- Класс декорирует класс

"""

# ===========================================================================================================
# КАК СОЗДАТЬ ПРОСТОЙ ДЕКОРАТОР ДЛЯ ФУНКЦИИ
# ===========================================================================================================
# 1. создаем функцию-декоратор
# 2. создаем внутреннюю функцию обертку wrapper. Все аргументы из внешней функции ей доступны по дефолту. Она принимает неявно f + ее аргументы через *args, **kwargs.
# Простой декоратор будет прекрасно работать, но внешние программы в процессе работы будут выводить 
# имя функции и докстринг из wrapper - это создаст путаницу. Решение есть ниже - создать хороший декоратор.

# простой декоратор
def my_decorator(f):                          
    def wrapper(*args, **kwargs):             # функция обертка с аргументами функции. 
        print("код до вызова функции")
        f(*args, **kwargs)                    # вызов функции в обертке.
        print("код после вызова функции")
    return wrapper                            # возврат ссылки на обертку
    

@my_decorator                                 # Применяем декоратор к функции
def some_func():
    print('Код функции')

# При вызове функции, будет вызван декоратор, который выполнит обертку с вложенной в нее функцией.
some_func()                                    

# ===========================================================================================================
# КАК СОЗДАТЬ ХОРОШИЙ ДЕКОРАТОР
# ===========================================================================================================
# Хороший декоратор прописывает имя фуункции, строку документирования и словарь в обертку. Это нужно для внешних программ(профилировщиков и тп).


# === способ 1 =====
from time import time, sleep       

# Декоратор добавляет в обертку имя функции, докстринг и словарь с аргументами
def my_decorators(f):              
    def wrapper(*args, **kwargs):
        print('Some code in wrapper before f')
        f(*args, **kwargs)
        print('Some code in wrapper after f')
        # в обертке часто прописывают следующее:
        wrapper.__name__ = f.__name__            # прокидывает имя функции 
        wrapper.__doc__ = f.__doc__              # прокидывает докстринг
        wrapper.__dict__.update(f.__dict__)      # добавляет аргументы
    return wrapper

# функция
@my_decorators
def some_func(x):
    """Docstring from some_func"""
    print("I want to sleep " + str(x) + " sec...")
    sleep(x)


# проверяем
some_func(5)
print(some_func.__name__)           # some_func
print(some_func.__doc__)            # Docstring from some_func
print(some_func.__dict__)           # {}


# === способ 2 =====
from functools import wraps  
# Декоратор с wraps делает то что напсано выше - прокидывает данные функции в обертку
def my_decorators(f):              
    @wraps(f)
    def wrapper(*args, **kwargs):
        print('Some code in wrapper before f')
        f(*args, **kwargs)
        print('Some code in wrapper after f')
    return wrapper

# функция
@my_decorators
def some_func(x):
    """Docstring from some_func"""
    print("I want to sleep " + str(x) + " sec...")
    sleep(x)

# проверяем
some_func(5)
print(some_func.__name__)           # some_func
print(some_func.__doc__)            # Docstring from some_func
print(some_func.__dict__)           # {'__wrapped__': <function some_func at 0x7f72dd73f9d0>}

# wraps передает в обертку в поле __wrapped__ оригинал функции
print(some_func.__wrapped__)        # <function some_func at 0x7fa37555d940>


# ===========================================================================================================
# КАК СОЗДАТЬ ДЕКОРАТОР ДЛЯ МЕТОДА КЛАССА
# ===========================================================================================================
# все тоже самое как в функции + передать self в обертку + self вызов метода. Если передать *args, **kwargs,
# то self можно не указывать - в примере ниже указано для наглядности. 

def method_decorator(m):
    def wrapper(self, *args, **kwargs):              # self
        print("код до вызова метода")
        m(self, *args, **kwargs)                     # self
        print("код после вызова метода")          
    return wrapper

class Man:
    @method_decorator
    def say_hello(self):
        print('hello')

ivan = Man()
ivan.say_hello()


# ===========================================================================================================
# КАК СОЗДАТЬ ДЕКОРАТОР С АРГУМЕНТАМИ
# ===========================================================================================================
# Декоратор с аргументами - обычная функция, возвращающая стандартный декоратор. 
# этот код вызывает функцию несколько раз
from time import sleep

def repeat_func(times):                  # простая функция - принимает аргумент и возрвращает декоратор
    def decorator(f):                    # декоратор принимает функцию
        def wrapper(*args, **kwargs):    # обертка принимает f(неявно в args) + другие аргументы
            for _ in range(times):       # вызов функции несколько раз
                f()
        return wrapper                   # сылка на обертку с функцией
    return decorator                     # ссылка на декоратор

# ВАЖНО: repeat_func здесь является обычной функцией, а не декоратором. 
# В скобках происходит вызов функции, которая вернет декоратор с передачей в него аргументов.
@repeat_func(5)
def some_func():
    print('hello world')
    sleep(2)

# вызов
some_func()

# ===========================================================================================================
# ДЕКОРАТОР ДЛЯ КЕШИРОВАНИЯ РЕЗУЛЬТАТА ФУНКЦИИ
# ===========================================================================================================
# если аргументы будут изменяемыми, то надо придумать неизменяемые ключи

def cache(f):
    def wrapper(*args):                          # *args должны быть неизменяемым типом - они будут ключами словаря
        if args in wrapper.cache:                # если есть в кеше - покажи
            print("Берем из кеша: " + str(wrapper.cache[args]))
        else:       
            res = wrapper.cache[args] = f(*args) # иначе положи в словарь результат функции с этими арг
            print("Вычисляем и кладем в кеш: " + str(res))
    wrapper.cache = {}                           # создаем словарь для кеша в декораторе
    return wrapper


@cache
def summa(x, y):
    return x + y

# запускаем
summa(5, 15)           # Вычисляем и кладем в кеш: 20
summa(5, 15)           # Берем из кеша: 20
summa(7, 11)           # Берем из кеша: 18
print(summa.__dict__)  # {'cache': {(5, 15): 20, (7, 11): 18}}   словарь функции summa содержит словарь кеша 


# ===========================================================================================================
# ДЕКОРАТОР ЗАМЕРА ВРЕМЕНИ ВЫПОЛНЕНИЯ
# ===========================================================================================================
from time import time, sleep

def timer(f):
    def wrapper(*args, **kwargs):
        start = time()
        f(*args, **kwargs)
        res = time() - start
        print('Total: ' + str(res))
    return wrapper

@timer
def some_func():
    print("Doing something 3 sec...")
    sleep(3)

some_func()


# ===========================================================================================================
# КЛАСС ДЕКОРИРУЕТ ФУНКЦИЮ
# ===========================================================================================================

class Cached:
    def __init__(self, f):
        self.f = f                              # сохраняем в объект функцию
        self.cache = {}                         # создаем кеш внутри объекта
        self.__name__ = f.__name__              # присваиваем объекту имя функции
        self.__doc__ = f.__doc__                # прокидывает докстринг
        self.__dict__.update(f.__dict__)        # добавляет аргументы

    def __call__(self, *args):                  # класс будет вести себя как функция
        if args in self.cache:
            return self.cache[args]
        res = self.cache[args] = self.f(*args)
        return res


# выполяется __init__() - создается объект класса Cached
# внутрь объекта передается функция
# теперь say_hello - экземпляр класса Cached(так происходит подмена)
@Cached
def say_hello():
    print('hello')

# когда мы вызываем функцию - мы вызываем метод __call__ экземпляра Cached
say_hello()