# ================================================================================================================
# ФУНКЦИИ
# ================================================================================================================
# функция - объект, ее можно присвоить переменной без вызова: bar=foo. Вызвать можно так: bar().
# параметры функции - локальные переменные(аргументы), которым присваиваются значения в момент вызова
# значения по умолчанию вычисляются 1 раз в точке выполнения инструкции def. Использование списков и словарей(изменяемых объектов) по умолчанию необходимо избегать - иначе они будут использоваться всеми последующими вызовами функции.
# значение аргумента копируется в новую ячейку памяти, поэтому, изменение значений в функции никак не скажется на значениях переменных в глобальном пространстве)
# return - обеспечивает выход из функции. Если не указан, то неявно return None.

# ================================================================================================================
# ОБЛАСТЬ ВИДИМОСТИ ФУНКЦИИ
# ================================================================================================================
Существует 2 типа контекста(области видимости): локальный и глобальный.
Каждая функция при определении создает свою локальную облать видимости(свое пространство имен).
После выполнения кода функции, эта область со всеми переменными уничтожается.
Если функция вызывает другую функцию, то и для этого вызова создается новая локальная область видимости со своим пространством имен.

Свободные переменные - используются в блоке кода, но определены в глобальном пространстве имен модуля. 
Локальные переменные - определены в блоке кода. Доступна только в блоке функции и вложенных блоках(кроме nonlocal и global).


# === Глобальная область видимости(область видимоти модуля)
a = 7
# глобальная переменная. 
# доступна для ЧТЕНИЯ в любой функции, любой вложенной функции, везде.
# не доступна для ИЗМЕНЕНИЯ в любой функции, любой вложенной функции.


g = 10
# глобальная переменная
# нельзя изменить внутри функции без global

hello = 'hello'         
# глобальная переменная

def foo(x, y=5, z=hello, *args, **kwargs):
    # x - аргумент функции
    # y - именованный аргумент со значением по дефолту
    # z - именованный аргумент со значением из гл. обл.
    # *args, **kwargs - кортеж и словарь - любые аргументы передаваемые в функцию
    """Краткое описание цели объекта.
    
    Вторая строка должна быть пустой А остальные - абзацами.
    Несколькими абзацами, описывающими соглашения о вызовах объекта, 
    его побочные эффекты и т. д.
    """
    # === Локальная область видимости foo
    
    global g        
    # g принадлежит глобальному пространству имен(пространству модуля).
    # рекомендуется указывать первой в блоке. 
    # global можно использовать как в простых функциях, так и во вложенных  
    # с помощью global можно определить в функции глобальную переменную, которая ранее отсутствовала
    g = 150             # это изменит b в глобальной видимости 

    b = a * 10
    # b - локальная переменная
    # b не доступна для ЧТЕНИЯ в глобальной области
    # b доступна только для ЧТЕНИЯ в области видимости вложенной функции. Ее нельзя там изменить без nonlocal.
    # здесь 'a' называется свободной переменной. Определена в гл. обл.

    n = 60              # локальная переменная
                

    def inner_func():   # вложенная функция

        # === Локальная область видимости inner_func
        # вложенной функции доступны все переменные из области внешней функции.
        
        z = b / 5 * a
        # z - локальная переменная
        # z не доступна для ЧТЕНИЯ в глобальной области 
        # z не доступна для ЧТЕНИЯ в области видимости внешней функции 
        # здесь 'a' называется свободной переменной. Определена в гл. обл.
        # здесь 'b' называется нелокальной переменной. Определена во внешней функции.
    
        nonlocal n      
        # связывает n с внешней переменной из ближайшей области видимости(внешняя функция), кроме глобальной
        # n должна существовать в ближайшей видимости
        # nonlocal используются только во вложенных функциях
        n+=1            # это изменит внешнюю n

        return z
    
    inner_func()        # вызов внутренней функции
    return g, a, n      # выход из функции с возвратом кортежа


print(foo(100))            # (5, 0) вызов функции
print(type(foo))           # <class 'function'>
print(foo.__dict__)        # {}
print(foo.__defaults__)    # (5, 'hello')
print(foo.__kwdefaults__)  # None


print(foo.__globals__)     # глобальное пространство имен в котором функция была определена(область ее модуля)
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7fe25bfa3bb0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': '/home/vadim/PycharmProjects/python_beazley/run_b.py', '__cached__': None, 'g': 150, 'hello': 'hello', 'foo': <function foo at 0x7fe25bf951f0>}


print(dir(foo))
['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

"""
__name__   имя функции
__dict__   словарь атрибутов. Может быть кешем декораторов и использоваться для записи облегченных замыканий.

Если функция изменяет значения аргументов или оказывает влияние на состояние других частей программы, про такие функции говорят, что они имеют побочные эффекты.

Переменные в функциях могут быть либо локальными, либо глобальными.
Каждая функция имеет свое локальное пространство имен. Сначала интерпретатор ищет переменные в нем.
Если нет, ищет в глобальном пространстве имен(пространстве имен модуля, в котором функция определена).
Если нет, ищет во встроенном в интерпретатор пространстве имен. 
Если нет - NameError.

Во вложенных функция переменная ищется сначала в своей локальной области видимости, потом во внешней и далее..
Внутренней функции доступны все переменные из внешней области видимости.
Внутренние функции не определены до тех пор, пока не будет вызвана родительская функция.

""" 

# значения параметров по умолчанию создаются 1 раз при определении функции
# при каждом вызове функция будет добавлять значение в список
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))        # [1]
print(f(2))        # [1, 2]
print(f(3))        # [1, 2, 3]

# ================================================================================================================
# АНОТАЦИИ ФУНКЦИИ
# ================================================================================================================
# Для аннотаций сложных или пользовательских типов необходимо использовать модуль typing.
def foo(age: int, name :str='Ivan') -> str:
    print(foo.__annotations__)               # {'age': <class 'int'>, 'name': <class 'str'>, 'return': <class 'str'>} 
    return f'My name is {name}, I`am {age}.'

print(foo('Ivan', 23))


from typing import List, Dict

List[int]
# typing.List[int]

Dict[str, int]
# typing.Dict[str, int]

# ================================================================================================================
# ВЫЗОВ ВНУТРЕННЕЙ ФУНКЦИИ В ЗАВИСИМОСТИ ОТ ПЕРЕДАННОГО АРГУМЕНТА
# ================================================================================================================
# Функции могут возвращать поведение.
# talk не вызывает внутреннюю функцию. Он принимает аргумент и возвращает соответствующий объект функции.
def talk(n):
    def hello(name):
        return f'Привет {name}.'
    def goodbye(name):
        return f'Пока {name}.'
    if n > 0:
        return hello
    else:
        return goodbye

# вызов внутренней функции
print(talk(1)('Ivan'))            # Привет Ivan

# ================================================================================================================
# ПЕРЕДАЧА ФУНКЦИИ КАК АРГУМЕНТА ДРУГОЙ ФУНКЦИИ
# ================================================================================================================
# принимает объект функции и вызывает его
def talk(say):
    prt = say('Мир')
    print(prt)

def hello(name):
    return f'Привет {name}.'

def goodbye(name):
    return f'Пока {name}.'

talk(hello)                       # Привет Мир.


# === РЕКУРСИВНЫЕ ФУНКЦИИ ========================================================================
# Рекурсия - функция, которая вызывает сама себя.

import sys

print(sys.getrecursionlimit())                 # 1000 by default
sys.setrecursionlimit(5000)                    # устанавливает глубину рекурсии. Максимум зависит от платформы.

def countDown(start):
    print(start)
    start = start - 1
    if start >= 0:
        countDown(start)                         # вызов себя 

countDown(5)


# ================================================================================================================
# АНОНИМНЫЕ ФУНКЦИИ LAMBDA
# ================================================================================================================
lambda a, b: a+b
# синтаксически ограничены одним выражением
# им не нужно придумывать имя, но это возможно
# не не могут содержать return, pass, assert или raise
# не поддерживает аннотации типов

# используются со встроенными функциями zip(), map(), filter(), а также reduce()
kilometer = list(map(lambda x: x * 1.6, mile_distances))

# c ключевыми функциями
list_d.sort(key=lambda i: i[1])

# в качестве списка lambda-выражений
doit = [(lambda x,y: x+y), (lambda x,y: x-y), (lambda x,y: x*y), (lambda x,y: x/y)]

# в качестве словаря, содержащего lambda-функции
doit = {'neg':lambda x: x-1, 'abs':lambda x: abs(x)-1, 'zero':lambda x: x}

# === MAP =============================================================================
# применяет функцию к итерируемой последовательности
# возвращает map объект с поддержкой next()

lst = [1,-2,3,-4,-5]
def sq(x):
    return x**2

b = map(sq, lst)
print(b)                               # <map object at 0x7faf12eee100>
print(next(b))                         # 1 - результат первой итерации
print(list(b))                         # [4, 9, 16, 25] оставшийся результат

# аналог map через генератор выражений
b = (sq(x) for x in lst)             # <generator object <genexpr> at 0x7f678c401430>      
print(next(b))                       # 1 - результат первой итерации
print(list(b))                       # [4, 9, 16, 25] оставшийся результат

# пример с map: строка наоборот 
b = map(lambda x: x[::-1], lst)        

# === FILTER =============================================================================
# фильтрует то, что не проходит и возвращает все что соответствует условию(отдает True)
# функция должна вощвращать True или False
numbers=[1,2,3,4,5,6,7,8,9,10]

# функция определяет четное число или нет
def odd_filter(x):
    if (x % 2) == 0:
        return True
    else:
        return False


b = filter(odd_filter, numbers)      # <filter object at 0x7fb86efa1fd0>
print(next(b))                       # 2 - результат первой итерации
print(list(b))                       # [4, 6, 8, 10] оставшийся результат

# === ZIP =============================================================================
# Объединяет элементы упорядоченных коллекций по индексам.
# Длина коллекции на выходе = длине наименьшей из указанных коллекций.

a = [1,2,3,4]
b = [5,6,7,8,9,10]

it = zip(a, b)

it = zip(a, b)                       # <zip object at 0x7f1039809580>
print(next(it))                      # (1, 5)  - результат первой итерации
print(list(it))                      # [(2, 6), (3, 7), (4, 8)]  оставшийся результат


# === REDUCE =============================================================================
from functools import reduce

# reduce(function, iterable, initializer=None)
# reduce позволяет привести несколько элементов к 1 значению
# reduce кумулятивно применяет функцию к последовательности 
# initializer - стартовое значение для начала отсчета

items = [1,2,3,4,5]

sum_all = reduce(lambda x,y: x + y, items)    # x = x + y(накопленое значение), y - следующий элемент итерации 
print (sum_all)                               # 15


# === SORT =============================================================================
# List имеет встроенный метод sort
# исходник меняется
# сортирует элементы по возрастанию

a=[1,-45,3,2,100,-4]

a.sort()               # список изменился
print(a)               # [-45, -4, 1, 2, 3, 100]

# === SORTED =============================================================================
# sorted(iterable,key=None,reverse=False)
# вернет новый отсортированный список, исходник не меняется.
# По умолчанию сортирует по возрастанию.
# key - ссылка на собственную сортирующую функцию

# простая сортировка списка
a=(1,-45,3,2,100,-4)

# простая сортировка списка
print(sorted(a))                           # [-45, -4, 1, 2, 3, 100]

# сортировка с реверсом
print(sorted(a, reverse=True))             # [100, 3, 2, 1, -4, -45]
                            
# сначала четные, потом нечетные
print(sorted(a, key=lambda x: x%2))        # [2, 100, -4, 1, -45, 3]


a=[1,4,3,6,5,2]
# четные возвращаются как есть, к нечетным прибавляем 100
def funcSort(x):
    if x%2 == 0:
        return x
    else:
        return x+100


print(sorted(a, key=funcSort))
# [101, 4, 103, 6, 105, 2] - это ключи, которые получились согласно алгоритму функции
# [2, 4, 6, 1, 3 ,5] результат сортировки по этим ключам происходит сортировка

# === ENUMERATE =============================================================================
# enumerate(sequence, start=0)
# (принимает любой итерируемый объект, start – начальное значение индекса)
# выдает кортеж(индекс, значение элемента)
a = [1, 4, 2, -5, 0, 11]

for e in enumerate(a):
    print(e)

g = enumerate(a)          # <enumerate object at 0x01B5F628>
print(next(g))            # (0, 1) результат первой итерации
print(list(g))            # [(1, 4), (2, 2), (3, -5), (4, 0), (5, 11)] оставшиеся элементы итератора


# === ДРУГИЕ ФУНКЦИИ =========================================================================

# абсолютное значение числа
abs(-5.6)                    # 5.6

# принимает число - вернет символ юникода
chr(65)                      # A

# принимает символ юникода - вернет число
ord('A')                     # 65

# является ли объект вызываемым
callable(4)                  # False

# возвращает хэш объекта
hash('Hello World')          # 6259791720863183635


"""
=== Генератор ==========================================================================
Генератор – это функция, которая воспроизводит последовательность значений и может использоваться
при выполнении итераций.
Слово yield объявляет объект-генератор.
Объект-генератор выполняет функцию, когда вызывается метод __next__(). Метод работает пока не будет
встречена инструкция yield, которая остановит выполнение и вернет результат
"""
def foo(x):
    while 1:
        print(x)
        yield x
        x += 1

c = foo(5)
c.__next__()
c.__next__()









