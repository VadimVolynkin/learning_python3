# http://toly.github.io/blog/2014/03/05/advanced-design-patterns-in-python/

Генераторы часто используются для работы с потоками данных и большими файлами, создания бесконечных последовательностей, счетчиков вызовов. Генератор, как и итератор держит в памяти при переборе только 1 элемент и перебирать последовательность можно только 1 раз. 

Генератором может стать любой объект с __iter__(). 
Есть 2 способа создания генератора: функции и выражения, работают они одинаково:

Генераторные функции - особый вид функций, который возвращает итератор.
Вместо return(выход из функции) в генераторе используется yield - оно объявляет объект генератором и возвращает элемент итерации. У генератора может быть несколько yield. Следующий yield сработает после нового вызова next().
Генератор вызванный в функции next() возвращает следующий объект или работате до следующего yield.

# ===============================================================================================================
# СОЗДАНИЕ ФУНКЦИИ ГЕНЕРАТОРА
# ===============================================================================================================
Генератор – это функция, которая воспроизводит последовательность значений и может использоваться при выполнении итераций.

Объект-генератор выполняет функцию, когда вызывается метод __next__(). Метод работает пока не будет встречена инструкция yield, которая остановит выполнение функции, вернет результат, вернет контроль выполнения потока. При следуюзем вызове next() функция вернет следующий объект последовательности.

# эта функция-генератор итерирует ограниченное количество раз
# в файле про итераторы есть аналогичный пример через создание своего класса-итератора.
# генераторная функция
def gen_func(limit):
    while limit > 0:
        limit -= 1
        yield limit    # yield создает генератор и возвращает оставшийся limit

# создаем генератор
gen = gen_func(3)      
print(type(gen))       # <class 'generator'>

print(next(gen))       # 2
print(next(gen))       # 1
print(next(gen))       # 0
print(next(gen))       # StopIteration


# ===============================================================================================================
# ГЕНЕРАТОР БЕСКОНЕЧНОЙ ПОСЛЕДОВАТЕЛЬНОСТИ
# ===============================================================================================================
# Такой генератор последовательноти уже существует - itertools.count()

def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

# запуск генератора через for - будет автоматически итерировать до бесконечности
for i in infinite_sequence():
   print(i, end=" ")
   
# запуск генератора через next() - выдаст только 1 итерацию
gen = infinite_sequence()
next(gen)
next(gen)


# ================================================================================================================
# COMPREHENSIONS
# ================================================================================================================


# ===== ГЕНЕРАТОРЫ СПИСКОВ =======================================================================================
Генератор списков возвращает готовый список. Ниже используется:
- обычный итератор range(10)
- выходное выражение x**2 for x
- опциональное условие if x%2 != 0

a = [x**2 for x in range(10) if x%2 != 0]    # а - готовый список с результатами

Результирующий список вычисляется и сохраняется в память сразу. Это не проблема для небольших списков, но в больших списках это может вызвать слишком большой расход памяти. 
Если результирующий список больше доступной памяти, то лучше использовать генератор выражений.
Если памяти достаточно - можно использовать список - он работает быстрее генератора.

# ===== ВЫРАЖЕНИЯ-ГЕНЕРАТОРЫ =====================================================================================
Выражения-генераторы  не хранят в памяти все значения сразу, а генерируют их по мере необходимости, то есть, при проходе к следующему значению. Это снижает размер занимаемой памяти в больших последовательностях.
В выражении-генераторе нельзя определить число элементов через len(b) или получить доступ к отдельному элементу по индексу b[5].

b = (x**2 for x in range(10) if x%2 != 0)
print(b)          # <generator object <genexpr> at 0x0000020E8F429C80>
print(len(b))     # TypeError: object of type 'generator' has no len() - нельзя узнать длину
print(b[5])       # TypeError: 'generator' object is not subscriptable - нельзя получить элемент по индексу
c = list(b)       # make list - получим список - list заставит выполнить все итерации

# выражение-генератор можно итерировать через for
for x in b:
    print(x)


# ===== ГЕНЕРАТОРЫ МНОЖЕСТВ ======================================================================================
elements = [1, 2, 1, 3, 2]
new_set = {n * 2 for n in elements}           # {2, 4, 6} умножит на 2 и удалит дубли

# ===== ГЕНЕРАТОРЫ СЛОВАРЕЙ ======================================================================================
numbers = {'one': 1, 'two': 2, 'three': 3}
new_dict = {v: k for k, v in numbers.items()} # {1: 'one', 2: 'two', 3: 'three'} меняем местами ключи и значения словаря







# TODO Сопрограммы и выражения yield ==========================================================
yield может также использоваться как выражение, стоящее справа от оператора присваивания
Закрыть поток входных данных можно вызовом метода close()