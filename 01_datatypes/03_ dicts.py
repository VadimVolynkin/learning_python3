# ======================================================================================================
# DICT
# ======================================================================================================
# изменяемый тип данных
# Ordered dict до Питона 3.7 необъединение нескольких списков с помощью оператора +;упорядоченные наборы пар ключ-значение (номеров позиций в словарях нет), порядок добавления не важен.
# объект словаря хранит лишь указатели, а не сами значения
# ключ не меняется - hashable объект неизменяемого типа(строка, число, кортеж)
# вес - 48 байт

dir({}) #show all methods =================================================
['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

# ======================================================================================================
# МЕТОДЫ СЛОВАРЯ
# ======================================================================================================

mydict = {}                   # создает словарь
dict.clear()                  # очищает словарь

dict.copy()                   # возвращает неглубокую копию - новый объект словаря со старыми значениями
dict.deepcopy()               # возвращает глубокую копию - новый объект словаря с новыми значениями

dict.update(other)            # добавляет новые пары из other(другой словарь, пары в кортеже или key=value), обновляет старые, возвращает None.
dict |= other                 # Python 3.9+

dict = {**dict1, **dict2}     # создание нового словаря из 2
dict = dict1 | dict2          # Python 3.9+

dict.fromkeys(seq, value)     # создает словарь с ключами из seq и значением value (по умолчанию None).

dict.items()                  # возвращает пары (ключ, значение).
dict.keys()                   # возвращает ключи в словаре.
dict.values()                 # возвращает значения в словаре.

dict.get(key, default)        # возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

dict.setdefault(key, default) # возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ с значением default (по умолчанию None).

dict.pop(key, default)        # удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

dict.popitem()                # удаляет и возвращает пару (ключ, значение) начиная с конца словаря. Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены до Python-3.7.

reversed(dict)                # Python 3.8+ Вернет обратный порядок по ключам

len(dict)                     # длина словаря
iter(dict)                    # создание объекта итератора

list(dict)                    # создание списка ключей словаря
list(dict.keys())
dict.keys()

dict['key']                   # если нет такого ключа - KeyError
dict['key'] = 'value'         # создаст ключ если нет, перезапишет значение если уже есть такой ключ
del dict[key]                 # если нет такого ключа - KeyError

key in dict                   # наличие ключа
key in dict.keys()

key not in dict               # отсутствие ключа
key not in dict.keys()


# ===== СОРТИРОВКА ПО КЛЮЧУ =================================================
num_dict = {'b': 13, 'd': 30, 'e': -32, 'c': 93, 'a': 33}

sorted_by_key = {key: val for key, val in sorted(num_dict.items())}
# {'a': 33, 'b': 13, 'c': 93, 'd': 30, 'e': -32}

# ===== СОРТИРОВКА ПО ЗНАЧЕНИЮ ПО ВОЗРАСТАНИЮ ===============================
sorted_by_val = {key: val for key, val in sorted(num_dict.items(), key=lambda x:x[1])}
# {'e': -32, 'b': 13, 'd': 30, 'a': 33, 'c': 93}

# ===== ФИЛЬТРАЦИЯ ПО ЗНАЧЕНИЮ ==============================================
filter_ge_30 = {key: val for key, val in num_dict.items() if val >= 30}
# {'d': 30, 'c': 93, 'a': 33}

# ===== ИЗ СПИСКА В СЛОВАРЬ =================================================

# сначала сделаем из словаря списки
a = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
lk = [x for x in a.keys()]                                       # ['a', 'b', 'c', 'd']
lv = [x for x in a.values()]                                     # [10, 20, 30, 40]
lt = [x for x in a.items()]                                      # [('a', 10), ('b', 20), ('c', 30), ('d', 40)]

# далее варианты преобразования
dict_generator = {lk[i]: lv[i] for i in range(len(lk))}          # {'a': 10, 'b': 20, 'c': 30, 'd': 40}

to_dict_from_2lists = dict(zip(lk, lv))                          # {'a': 10, 'b': 20, 'c': 30, 'd': 40}

to_dict_from_list_tuple = dict(lt)                               # {'a': 10, 'b': 20, 'c': 30, 'd': 40}


# ===== СЛОВАРЬ В JSON С ЗАПИСЬЮ В ФАЙЛ =====================================
d = {'name': 'Ivan', 'age': 30, 'car': None, 300: 500}

import json
myfile = open('my_json', 'w')
dict_to_json = json.dump(d, fp=myfile)
# {"name": "Ivan", "age": 30, "car": null, "300": 500}


# ===== СЛОВАРЬ В JSON СТРОКУ ===============================================
import json
dict_to_str = json.dumps(d)
# {"name": "Ivan", "age": 30, "car": null, "300": 500}


# ===== ГЕНЕРАТОРЫ СЛОВАРЕЙ =================================================

# словарь из последовательности от 0 до 7, где ключ = значение **2
d = {a: a ** 2 for a in range(7)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

# из списка в нумерованный словарь
hl = ['h', 'e', 'l', 'l', 'o']
d = {a: hl[a] for a in range(len(hl))}                # то же самое можно реализовать так: dict(enumerate(hl))
# {0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o'}

# ======================================================================================================
# ORDERED DICTS(упорядоченный словарь)
# ======================================================================================================
# Такой словарь содержит упорядоченные пары ключ-значение, их можно вызвать по индексу.
# При сравнении важен порядок добавления - 2 словаря с одинаковыми значениями, но разным порядком добавления будут не равны.
# подробнее в папке с библиотеками питона, в collections

from collections import OrderedDict
d = OrderedDict()


