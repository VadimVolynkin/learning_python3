# ================================================================================================================
# LIST
# ================================================================================================================
# изменяемый тип данных, упорядочен по индексам, допускает неуникальные значения
# представляет собой список ссылок на объекты
# вес - 40 байт

['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

# ================================================================================================================
# МЕТОДЫ СПИСКОВ
# ================================================================================================================

list.copy()                     # создаст новый объект списка с ссылками на теже объекты. Если объекты мутабельны, то изменение в 1 списке изменит второй список.
newlist = copy.deepcopy(mylist) # создаст новый объект списка с новыми объектами-копиями

list1.extend(list2)             # расширение list1
list1 += list2                  

r = list1 * 2                   # создаст повторяющийся список

r = list1 + list2               # объединение списков в новом списке

list.append(x)                  # добавляет элемент в конец списка
list.insert(i, x)               # добавляет элемент на указанную позицию( i – позиция, x – элемент)

list.reverse()                  # меняет порядок элементов в списке на противоположный
list.sort()                     # сортирует список

list.count(x)                   # количество элементов x в списке
list.index(x)                   # вернет позицию первого найденного элемента x в списке

list.remove(x)                  # удаляет элемент из списка (только первое вхождение)
list.pop(i)                     # вернет и удалит элемент из позиции i, либо последний pop()
list.clear()                    # удаляет все элементы (список становится пустым [])


# ================================================================================================================
# ВАРИАНТЫ ПРИМЕНЕНИЯ
# ================================================================================================================

# примеры списков для демонстрации работы с ними
elements = [3, 56, 23, 99, 102, 44, 6]
cars = ['audi', 'bmw', 'volvo', 'opel']

# сделаем из словаря списки
a = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
lk = [x for x in a.keys()]                                       # ['a', 'b', 'c', 'd']
lv = [x for x in a.values()]                                     # [10, 20, 30, 40]
lt = [x for x in a.items()]                                      # [('a', 10), ('b', 20), ('c', 30), ('d', 40)]
ll = [[k, v] for k, v in a.items()]                              # [['a', 10], ['b', 20], ['c', 30], ['d', 40]]

# ===== СОРТИРОВКА С РЕВЕРСОМ ========================================
elements.sort(reverse = True)                                    # [102, 99, 56, 44, 23, 6, 3]
                                            
# ===== СПИСОК В СТРОКУ ==============================================
elements_to_str = ', '.join(cars)                                # audi, bmw, volvo, opel
                                          
# ===== СПИСОК В СТРОКУ JSON =========================================
import json
list_to_str = json.dumps(elements)
print(list_to_str)                                              # [3, 56, 23, 99, 102, 44, 6]
print(type(list_to_str))                                        # <class 'str'>


# ====== СПИСОК В СЛОВАРЬ ============================================

to_dict_from_cars = {x: cars[x] for x in range(len(cars))}
# {0: 'audi', 1: 'bmw', 2: 'volvo', 3: 'opel'}

to_dict_from_2lists = dict(zip(lk, lv))
# {'a': 10, 'b': 20, 'c': 30, 'd': 40}

to_dict_from_generator = {lk[a]: lv[a] for a in range(len(lk))}
# {'a': 10, 'b': 20, 'c': 30, 'd': 40}

to_dict_from_list_tuple = dict(lt)
# {'a': 10, 'b': 20, 'c': 30, 'd': 40}

to_dict_from_list_of_lists = dict(ll)
# {'a': 10, 'b': 20, 'c': 30, 'd': 40}

enumerate_list_to_dict = dict(enumerate(cars))
# {0: 'audi', 1: 'bmw', 2: 'volvo', 3: 'opel'}



# ===== СПИСОК В JSON ================================================
import json
list_to_json = json.dumps(cars)
print(list_to_json)


# ===== СПИСОК В SET(множество) ======================================
print(set(elements))


# ===== ГЕНЕРАТОРЫ СПИСКОВ ===========================================
# результирующий список формирутся сразу весь, поэтому может занимать очень много памяти, иногда лучше использовать генератор выражений.
# генераторы списков могут быть вложенные

# умножим элементы списка на 3
c = [c * 3 for c in elements]             # [9, 168, 69, 297, 306, 132, 18]

# выведем асе числа от 1 до 15
nums = [i for i in range(1, 15)]          # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]


# ===== ОЧЕРЕДЬ FIFO (первым пришел, первым вышел) ====================
# стандартные методы списка для FIFO нееффективны - добавление элемента нужно производить в начало, а это потребует изменение всех индексов очереди. Лучше использовать очередь deque - она имеет индексы в оба направления и метод appendleft.

from collections import deque
queue = deque(["Eric", "John", "Michael"])

# добавляет в конец
queue.append("Terry")

# добавляет в начало
queue.appendleft("Graham")

# состояние очереди
print(queue)                                       # deque(['Graham', 'Eric', 'John', 'Michael', 'Terry'])

# извлекает первый элемент
print(queue.popleft())                             # Graham

# состояние очереди
print(queue)                                       # deque(['Eric', 'John', 'Michael', 'Terry'])

# извлекает последний элемент
print(queue.pop())                                 # Terry


# ===== СТЕК LIFO (последним пришел, первым вышел) ===================
# реализуется встроенными методами списка

list.append()
list.pop()


