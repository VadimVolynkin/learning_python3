# https://docs-python.ru/standart-library/modul-threading-python/klass-event-modulja-threading/

# =====================================================================================================
# Синхронизация потоков при помощи событий threading.Event()
# Это один из простейших механизмов связи между потоками: один поток сигнализирует о событии, а другие потоки ждут его.
# =====================================================================================================
# По умолчанию флаг имеет значение False.

Event.is_set()
# проверяет внутренний флаг - вернет True или False

Event.set()
# устанавливает значение внутреннего флага в True.
# Пробуждаются все потоки, ожидающие его выполнения.
# Потоки, которые вызывают метод Event.wait() после установки флага, не будут блокироваться вообще.

Event.clear()
# сбрасывает внутренний флаг на значение False
# потоки, вызывающие метод Event.wait(), будут блокироваться до тех пор, пока не будет вызван Event.set()

Event.wait(timeout=None)
# ожидает (блокирует выполнение), пока внутренний флаг станет True
# Если внутренний флаг при входе True, то метод сразу возвращает результат. В противном случае блокирует до тех пор, пока другой поток не вызовет метод Event.set() или пока не наступит необязательный timeout.
# При наступлении timeout флаг события не меняется - остается False.


# =====================================================================================================
# Пример синхронизации потоков при помощи threading.Event()  - 2 варианта
# =====================================================================================================

import threading, time

# установка глобального события(по умолчанию False)
event = threading.Event()  

# # 1. блокирует поток до настуления события
# def wait_event():
#     print('Старт WAIT_EVENT()')
#     event.wait()
#     print('Код обработки по событию в WAIT_EVENT()')


# # 1. создание и запуск дочернего потока с блокировкой до наступления события
# t1 = threading.Thread(name='blocking', target=wait_event)
# t1.start()


# 2. проверяет статус события без блокировки
def wait_timeout(time_out):
    print('Старт WAIT_TIMEOUT() ')
    while not event.is_set():                                         # пока не натупило событие
        is_set = event.wait(timeout=time_out)                         # блоктрует поток до события или тайм-аута
        print(f'TimeOut {time_out} секунды истек')
        if is_set:                                                  
            print('Код обработки по событию в WAIT_TIMEOUT()')
        else:
            print('Пока ждем события, код обработки чего-то другого')
            time.sleep(3)


# 2. создание и запуск дочернего потока без блокировки с ожиданием максимум 2 сек
t2 = threading.Thread(name='non-blocking', target=wait_timeout, args=(2,))
t2.start()

print('Ожидание перед вызовом Event.set()')
time.sleep(10)
event.set()                                                          # установка события в True
print('Установлено событие в основном потоке')















