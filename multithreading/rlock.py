# =====================================================================================================
# Синхронизация потоков при помощи блокировок threading.RLock().
# Создает объект блокировки для защиты от одновременного доступа к общему объекту нескольких потоков. В отличии от Lock осуществляет рекурсивную блокировку и разблокировку в пределах одного потока. Поток освобождается при разблокировке самого внешнего уровня вложенности.
# =====================================================================================================

RLock.acquire(blocking=True, timeout=-1)
# Если этот поток уже владеет блокировкой(это повторный вызов), то увеличивает уровень рекурсии на единицу и возвращает True. 
# Если другой поток владеет блокировкой, то текущий поток блокируется, пока не будет снята блокировка. Как только блокировка снята (не принадлежит ни одному потоку), то захватывает владение блокировкой, устанавливает уровень рекурсии на единицу и возвращает True. 
# Если более одного потока находятся в ожидании снятия блокировки, то только один из них сможет получить право владения блокировкой. В этом случае нет возвращаемого значения.
# blocking=False не блокирует поток, а проверит, сможет ли метод с blocking=True поставить блокировку, если нет, то вернет False, в противном случае установит блокировку и возвратит True.
# timeout > 0 - блокировать выполнение не более чем на ... сек или пока блокировка не будет получена. В этом случае, возвращает True, если блокировка была получена и False, если истек timeout.
# timeout = -1 - указывает на неограниченное ожидание. 


RLock.release()
# Метод снимает блокировку, уменьшив уровень рекурсии. RLock может освободить только тот поток, который его захватил. Освобождение происходит только после того, как был выполнен release() для внешнего acquire(). 
# Если рекурсия = 0, то состояние объекта unlocked (т.е. блокировка не принадлежит ни одному потоку). Если другие потоки в это время заблокированы, ожидая разблокировки, то разрешит выполнение ровно одному из них. 
# Если после декремента рекурсия > 0, то блокировка остается locked и принадлежит вызывающему ее потоку.
# Если метод вызывается при снятой блокировке, то RuntimeError.


# =====================================================================================================
# Пример работы с методами threading.RLock()
# =====================================================================================================
import threading, time


# создаем объект
rlock = threading.RLock()
print(rlock)                                 # <unlocked _thread.RLock object owner=0 count=0 at 0x7fa209b38f30>

# заблокируем 2 раза
print('First rlock :', rlock.acquire())      # True
print('Second rlock :', rlock.acquire())     # True and thread not blocked
print(rlock)                                 # <locked _thread.RLock object owner=140297275728000 count=2 at 0x7f9981311f30>

# разблокируем 2 раза
rlock.release()
rlock.release()
print(rlock)                                 # <unlocked _thread.RLock object owner=0 count=0 at 0x7f13840faf30>

# пробуем разблокировать уже разблокированное
# rlock.release()                            # RuntimeError: cannot release un-acquired lock

print('The End')


# =====================================================================================================
# Пример использования блокировки с менеджером контекста with
# =====================================================================================================
rlock_obj = threading.RLock()

# with автоматически поставит блокировку на объект и снимет ее по окончанию блока кода(как бы оборачивает ее)
with rlock_obj:
    doing_something()

# аналог без with
rlock_obj.acquire()                 # блокируем объект
try:                                # хорошая практика помещать в try
    doing_something()               # Работа с разделяемым ресурсом
finally:
    rlock_obj.release()             # разблокируем объект


























