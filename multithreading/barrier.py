# =====================================================================================================
# Синхронизация потоков при помощи threading.Barrier().
# Создает объект-барьер для количества parties потоков - примитив синхронизации для использования фиксированным числом потоков, которым необходимо ждать друг друга для одновременного старта.
# Каждый из потоков пытается преодолеть барьер, вызывая метод Barrier.wait() и блокируется, пока их количество не достигнет необходимого для прохождения барьера. При достижении этой цели все потоки освобождаются одновременно.
# =====================================================================================================

import threading

barrier = threading.Barrier(
  parties,                      # количества потоков
  action=None,                  # вызываемый объект - вызывается одним из потоков при их освобождении.
  timeout=None)                 # тайм-аут по умолчанию для метода Barrier.wait()


Barrier.wait(timeout=None)
# Ждет точку прохождения барьера (Когда все потоки, участвующие в барьере, вызвали wait), чтобы освободить все потоки одновременно.
# timeout используется вместо одноименного аргумента конструктора класса. Если время вызова истекло, то барьер переводится в нерабочее состояние.
# Возвращаемое значение - целое число от 0 до количества участвующих сторон
# Если указан action, то один из потоков вызовет его перед освобождением. Если вызов даст ошибку, то барьер переводится в неработающее состояние.
# Может вызвать исключение threading.BrokenBarrierError, если барьер нерабочий или сброшен во время ожидания потока.

Barrier.parties
# количество потоков, необходимых для прохождения барьера

Barrier.n_waiting
# количество потоков, уже ждущих прохождения барьера

Barrier.reset()
# возвращает барьер в пустое состояние. Все ожидающие его потоки получат threading.BrokenBarrierError.

Barrier.abort()
# ставит барьер в нерабочее состояние. Любые активные или будущие вызовы метода Barrier.wait() будут завершаться ошибкой threading.BrokenBarrierError.
# Метод можно использовать, если один из потоков должен прерваться, чтобы избежать тупиковой блокировки приложения.

Barrier.broken
# возвращает True, если барьер в нерабочем состояниибарьер в нерабочем состоянии


# =====================================================================================================
# Пример установки барьеров для потоков.
# будет создавать потоки и запускать их по 2
# =====================================================================================================

import threading, time

def worker(barrier):
    th_name = threading.current_thread().name
    print(f'{th_name} в ожидании барьера с {barrier.n_waiting} другими')
    try:
        worker_id = barrier.wait()
    except threading.BrokenBarrierError:
        print(f'{th_name} сброшен')
    else:
        print(f'{th_name} прохождение барьера {worker_id}')


# создаем барьер
barrier = threading.Barrier(2)

# сброс барьера
# barrier.abort()


# создаем и запускаем 10 потоков
NUM_THREADS = 10
threads = []
for i in range(NUM_THREADS):
    th = threading.Thread(name=f'Worker-{i}', target=worker, args=(barrier,))
    threads.append(th)
    print(f'Запуск {th.name}')
    th.start()
    time.sleep(2)

# блокируем основной поток программы до завершения работы всех потоков
for thread in threads:
    thread.join()















