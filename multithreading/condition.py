https://devpractice.ru/python-lesson-23-concurrency-part-2/

# =====================================================================================================
# Синхронизация потоков при помощи блокировок по условию threading.Condition().
# создает объект блокировки для защиты от одновременного доступа к общему объекту нескольких потоков, который предполагает ожидание готовности некоторого ресурса и оповещение об этом событии ждуших потоков.
# =====================================================================================================

import threading

cond_var = threading.Condition(lock=None)
# lock=None - объект блокировки threading.Lock() или threading.RLock(), который будет использоваться условием. По умолчанию создается threading.RLock. Блокировка является частью объекта Condition и не нужно отслеживать его отдельно.

# ===== Паттерн (Producer-Consumer, Производитель – Потребитель) =================================================================

# === На стороне Consumer’а: 
# Проверить доступен ли ресурс, если нет, то перейти в режим ожидания методом wait(), и ожидать оповещение от Producer’а, что ресурс готов. 
# Метод wait() может быть вызван с таймаутом, по истечении которого поток выйдет из состояния блокировки и продолжит работу.


# === На стороне Producer’а:
# Подготовить ресурс. Если ресурс готов, оповестить ожидающие потоки с помощью методов notify() или notify_all(). 
# notify() разблокирует 1 поток (если он вызван без параметров), а notify_all() все потоки, которые находятся в режиме ожидания.



Condition.acquire(*args)
# устанавливает базовую блокировку. Возвращает True или False.

Condition.release()
# снимает базовую блокировку

Condition.wait(timeout=None)
# Возвращает значение True, и если не истек заданный тайм-аут timeout, то False.
# Освобождает базовую блокировку, а затем блокирует выполнение кода до тех пор, пока он не будет разбужен уведомлением Condition.notify() или Condition.notify_all() для того же условия в другом потоке или пока не наступит необязательный тайм-аут. После пробуждения или истечения времени ожидания он повторно устанавливает блокировку выполнения кода и возвращает результат.
# Если поток вызвавший этот метод ранее не получил блокировку, то возникает ошибка RuntimeError.

# Блокировка не снимается методом RLock.release(), если она была получена несколько раз рекурсивно. Вместо этого используется внутренний интерфейс класса threading.RLock, который действительно разблокирует его, даже если он был рекурсивно получен несколько раз. Затем используется другой внутренний интерфейс для восстановления уровня рекурсии при повторной блокировке.


Condition.wait_for(predicate, timeout=None)
# Ждет, пока условие predicate не станет истинным. Условие predicate должно быть вызываемым объектом, выдающим логическое значение. Может быть предусмотрен timeout - максимальное время ожидания.
# Может использоваться для автоматизации проверки условий и упрощает вычисление тайм-аутов.

Condition.notify(n=1)
# Пробуждает не более n потоков, ожидающих переменной условия.
# Если поток, вызывающий этот метод, ранее не получил блокировку, то возникает ошибка RuntimeError.

Condition.notify_all()
# пробуждает все потоки, ожидающие условия


# =====================================================================================================
# Пример паттерна Производитель-Потребитель с помощью threading.Condition().
# =====================================================================================================


import threading, time

def consumer(cond):
    """ждет определенного состояния для использования ресурсов"""
    th_name = threading.current_thread().name
    print(f'Запуск потока потребителя {th_name}')
    with cond:
        cond.wait()                                                # ждет уведомление от производителя
        print(f'Обработка ресурса потребителем {th_name}')
        time.sleep(0.3)


def producer(cond):
    """подготовка ресурса, для использования потребителями"""
    th_name = threading.current_thread().name
    print(f'Запуск потока производителя {th_name}')
    with cond:
        print(f'{th_name} готовит ресурс для потребителей')
        time.sleep(0.5)
        print(f'{th_name} ресурс ГОТОВ!')
        cond.notify_all()                                          # шлет уведомление потребителям


# создаем объект условия
condition = threading.Condition()

# создание потоков потребителей
c1 = threading.Thread(name='Consumer-1', 
                      target=consumer,
                      args=(condition,))
c2 = threading.Thread(name='Consumer-2', 
                      target=consumer,
                      args=(condition,))

# создание потока потребителей производителя
p = threading.Thread(name='PRODUCER', 
                     target=producer,
                     args=(condition,))

# запуск потоков           
c1.start()
c2.start()
p.start()











