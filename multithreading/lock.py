# https://docs-python.ru/standart-library/modul-threading-python/klass-lock-modulja-threading/
# https://devpractice.ru/python-lesson-23-concurrency-part-2/

# =====================================================================================================
# Синхронизация потоков при помощи блокировок threading.Lock().
# реализует примитивные объекты блокировки для защиты от одновременного доступа к общему объекту нескольких потоков
# =====================================================================================================
# Если поток получил блокировку, то попытки получить его блокируются, пока поток не будет разблокирован. Любой поток может снять блокировку.

# Примитивная блокировка потока - это примитив синхронизации, который при блокировке не принадлежит конкретному потоку - его может разблокировать любой поток.
# Примитивная блокировка объекта может иметь 2 состояния: 
# - locked
# - unlocked(по умолчанию при создании)

Lock.acquire(blocking=True, timeout=-1)
# При успешном захвате объкта устанавливает блокировку(locked) и вернет True, если блокировка не получена (например истекло время ожидания timeout) блокировка получена -вернет False.
# blocking=True по умолчанию блокирует поток, пока блокировка не будет снята, затем снова установит ее в состояние "locked" и вернет True.
# blocking=False не блокирует поток, а проверит, сможет ли метод с blocking=True поставить блокировку, если нет, то вернет False, в противном случае установит блокировку и возвратит True.
# timeout > 0 - блокировать выполнение не более чем на ... сек или пока блокировка не будет получена.
# timeout = -1 - указывает на неограниченное ожидание. 
# Повторный вызов acquire() приведет к блокировке инициировавшего это действие потока до тех пор, пока Lock не будет разблокирован каким-то другим потоком с помощью метода release().

Lock.release()
# Снимает блокировку(unlocked) с заблокированного объекта - переводит на "unlocked" и возвращает результат своему экземпляру. 
# При вызове метода при снятой блокировки возникает исключение RuntimeError.
# Может быть вызван из любого потока, а не только из того, который заблокировал.
# Если какие-либо другие потоки уже заблокированы, то разрешает выполнение ровно одному из них. Какому - зависит от реализации. 

Lock.locked()
# проверяет состояние блокировки True или False


# =====================================================================================================
# Пример работы с методами threading.Lock()
# =====================================================================================================

import threading, time                              

lock = threading.Lock()                                     # create lock obj

print('check before lock :', lock.locked())                 # check lock -> False
print('first lock success :', lock.acquire())               # try to lock -> return True
print('try to do second :', lock.acquire(blocking=False))   # try to lock second time -> False
print('check after lock :', lock.locked())                  # check lock -> True
time.sleep(5)


def f1(lock):
    print('check status before release :', lock.locked())   # True
    lock.release()                                          # unlock
    print('check status after release :', lock.locked())    # False
    print('wait 5 sec...')
    time.sleep(5)
    print('hello from f1')

th1 = threading.Thread(target=f1, args=(lock,))
th1.start()


# =====================================================================================================
# Пример блокировки счетчика на время изменения
# =====================================================================================================

import threading, time

class Counter():

    def __init__(self, start=0):
        self.lock = threading.Lock()                     # создает объект блокировки в счетчике
        self.value = start                               # добавляет счетчик со стартовым значением value = 0

    def increment(self):
        th_name = threading.current_thread().name        
        print(f'Th: {th_name} - ждет блокировку')
        self.lock.acquire()                              # устанавливает блокировку во время изменения счетчика
        try:
            print(f'Th: {th_name} - получил блокировку')
            self.value = self.value + 1                  # добавляет единицу к счетчику
        finally:
            self.lock.release()                          # снимает блокировку


def worker(c):
    for i in range(2):                                   # увеличение счетчика проделываем 2 раза для каждого потока  
        th_name = threading.current_thread().name               
        print(f'Th: {th_name} - заснул на 2')
        time.sleep(2)                                    # делаем паузу
        c.increment()                                    # увеличим счетчик на единицу с блокировкой в процессе
    print(f'Th: {th_name} - сделано.')

# создает экземпляр счетчика
counter = Counter()

# запуск потоков с передачей счетчика
for i in range(2):
    t = threading.Thread(target=worker, args=(counter,))
    t.start()                

print('Ожидание рабочих потоков')
main_thread = threading.main_thread()                    # получаем основной поток
for t in threading.enumerate():                          # итерация всех живых потоков
    if t is not main_thread:                             # если не основной поток
        t.join()                                         # блокирует основной поток до полного выполнения дочерних
print(f'Счетчик: {counter.value}')                       # после их выполнения основной поток продолжается - выводит результат



# =====================================================================================================
# Пример использования блокировки с менеджером контекста with
# =====================================================================================================
lock_obj = threading.Lock()

# with автоматически поставит блокировку на объект и снимет ее по окончанию блока кода(как бы оборачивает ее)
with lock_obj:
    doing_something()

# аналог без with
lock_obj.acquire()                  # блокируем объект
try:                                # хорошая практика помещать в try
    doing_something()               # Работа с разделяемым ресурсом
finally:
    lock_obj.release()              # разблокируем объект







