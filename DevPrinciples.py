
# ===== DRY(Don’t repeat yourself - Не повторяйся)
Не надо дублировать код. Изменения кода должно происходить в 1 месте.


# ===== YAGNI(You aren't gonna need it - Вам это не понадобится)
Не надо делать то что не нужно. Делать нужно то что в ТЗ.
Лишняя функциональность:
- отнимает ресурсы на разработку, тестирование и поддержку
- может мешать дальгейшей разработке
- создает риски безопасности


# ===== KISS(Keep it simple, stupid - Делай проще, тупица)
Нужно избегать ненужной сложности. Простота должна быть одной из ключевых целей проектирования.


# ===== SOLID(single responsibility, open–closed, Liskov substitution, interface segregation и dependency inversion)
# 5 основных принципов объектно-ориентированного программирования и проектирования
# соблюдение этих принципов позволяет эффективно дополнять и изменять, читать, дебажить код - это экономит время и деньги


# === S(SRP, single responsibility principle, Принцип единственной ответственности)
Для каждого класса должно быть определено единственное назначение. Все ресурсы для выполнения этого назначения должны быть инкапсулировны в класс и подчинены только этой задаче.
Цель принципа SRP – бороться со сложностью, которая возникает в процессе разработки логики приложения. 
От себя: 1 сущность = 1 класс. Класс должен иметь атрибуты и методы для решения единственной задачи(описывать 1 сущность). 
Антипаттерн: GodObject

Примеры:
https://webdevblog.ru/primenenie-principa-edinoj-otvetstvennosti-v-python/

Композиция: позволяет создать такие функции, чтобы каждая из них выполняла только одну задачу, а комбинация их вместе выполняло бы нужное нам общую задачу.

Следование принципу:
1. Разделение больших классов, делающих многое
2. Слияние мелких классов и объединение в одном классе однотипоной


# === O(OCP, open–closed principle, Принцип открытости/закрытости)
Принцип открытости: класс можно дополнить новым функционалом.
Принцип закрытости: новый код не должен затрагивать старый(старый код закрыт для изменений, кроме багфикса). 

Принцип позволяет проводить тестирование кода единожды.
Как применять: 
- по Бертрану Мейеру: расширять код через наследование, при этом второй класс наследник может иметь другой интерфейс. Минус такого подхода - это приводит к потребности переписывания клиентского кода. Такой вариант сейчас редко применяется.
- по Бобу Мартину(полиморфный принцип открытости-закрытости): Клиентский код должен зависеть от неизменного интерфейса. Новый функционал(в новом классе) может делегировать вызовы старому коду или новый код может наследовать старый.


# === L(LSP, Liskov substitution principle, Принцип подстановки Барбары Лисков)
Объекты в программе могут быть заменены их наследниками без изменения свойств программы.
От себя: объекты родительских классов могут быть заменены обектами классов наследников и они должны корректно отработать.


# === I(ISP, interface segregation principle, Принцип разделения интерфейса)
Много специализированных интерфейсов лучше, чем один универсальный. 
Это повышает секюрность + клиенты видят только методы, которые им нужны.
Как применить: Каждому клиенту создать свой интерфейс!


# === D(DIP, dependency inversion principle, Принцип инверсии зависимостей)

# первый тип формулировки
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

# второй тип формулировки
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

От себя: зависимости на абстракциях, а не на чем то конкретном. 
Как применить: Все классы делать через интерфейсы. Если интерфейсов много, их удобно хранить в отдельном файле.
Это создает хороший балланс между hardcode и softcode, позволяя в любое место системы встроить дополнительный функционал.
























