# https://docs-python.ru/standart-library/paket-multiprocessing-python/poluchenie-svedenij-protsessah-modul-multiprocessing/


import multiprocessing
import os


# x = multiprocessing.cpu_count()              # 4 - количество имеющихся ядер процессора
# x = os.cpu_count()                           # 4 - количество имеющихся ядер процессора
# x = os.sched_getaffinity(0)                  # {0, 1, 2, 3} Количество ядер, которое может использовать текущий процесс


# x = multiprocessing.active_children()        # список всех живых дочерних процессов
# x = multiprocessing.current_process()        # возвращает объект Process текущего процесса
# x = multiprocessing.parent_process()         # возвращает объект Process родительского процесса. None если это родитель

# x = multiprocessing.freeze_support()         # поддержка замороженных процессов

# x = multiprocessing.get_all_start_methods()  # ['fork', 'spawn', 'forkserver'] список поддерживаемых методов запуска
# первый по умолчанию

# x = multiprocessing.get_context()      # <multiprocessing.context.ForkContext object at 0x7fb0c67a37c0> возвращает объект контекста
# x = multiprocessing.get_start_method() # fork возвращает имя метода запуска
# x = multiprocessing.set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))  # задает путь интерпретатора Python для доч проц. По умолчанию используется sys.executable
# x = multiprocessing.set_start_method('spawn') # устанавливает метод запуска дочерних процессов


# ==============================================================================================
# CREATE PROCESS
# ==============================================================================================
proc = multiprocessing.Process(
    group=None,             # не используется модулем
    target=None,            # вызываемый объект (функция)
    name=None,              # имя процесса
    args=(),                # аргументы для target
    kwargs={}, *,           # ключевые аргументы для target
    daemon=None             # флаг для демонизации процесса
    )


# ==============================================================================================
# РЕКОМЕНДАЦИИ
# ==============================================================================================
1. Избегайте общих ресурсов. Лучше использовать очереди или каналы между процессами, чем примитивы синхронизации.
2. Убедитесь,что аргументы методов прокси-объектов являются упакованы модулем pickle.
3. Не используйте прокси-объект из более чем одного потока, если вы не защитите его блокировкой.
4. Хорошей практикой является явное присоединение ко всем процессам, которые запускаются.
5. Лучше наследовать, чем pickle/unpickle. Процесс, которому нужен доступ к общему ресурсу, должен имеьт возможность унаследовать его от процесса-предка.
6. Избегайте завершения процессов с общими ресурсами методом Process.terminate() - это может сломать блокировки, семафоры, каналы и очереди.
7. Всякий раз, когда используется очередь, необходимо убедиться, что все элементы, помещенные в очередь, в конечном итоге будут удалены до присоединения к процессу.
8. Явная передача объекта общего ресурса конструктору дочернего процесса при fork в качестве аргумента.
9. Остерегайтесь замены sys.stdin на файловый объект. Если несколько процессов вызовут file.close() - одни и те же данные будут сброшены в него несколько раз.

# ========================================================================================================================

===== Существует 2 канала связи между процессами:

=== Очереди Queues, в собственной реализации
Очереди безопасны для потоков в разных ядрах процессора.

=== Каналы Pipes multiprocessing.Pipe()
Возвращает пару объектов, соединенных каналом, которые по умолчанию является duplex двусторонним.
Каждый объект имеет методы Pipe.send() - посылает данные в канал и Pipe.recv() - читает данные из канала.
Данные в канале могут быть повреждены, если два процесса или потока попытаются читать или записывать в один и тот же конец канала одновременно.

# ==============================================================================================

===== Примитивы синхронизации на разных ядрах
Блокировка Lock - только один процесс печатает на стандартный вывод за раз.
Без использования блокировки вывод различных процессов может все перемешать.


===== Несколько способов использования обзего состояния между процессами

=== Общая память Shared memory:
= multiprocessing.Value
= multiprocessing.Array

=== Серверный процесс Server process
multiprocessing.Manager() вернет объект SyncManager для управления серверным процессом, который содержит объекты Python и позволяет другим процессам манипулировать ими с помощью прокси-объектов.
Менеджеры серверных процессов более гибкие, чем использование объектов общей памяти, т. к. могут быть созданы для поддержки произвольных типов объектов, но они медленнее.
